name: Release

on:
  schedule:
    # Runs every day at midnight UTC for the nightly release.
    - cron: '0 0 * * *'
  workflow_dispatch:
    inputs:
      version:
        description: 'The version to release (e.g., v0.1.11). Required for manual patch releases.'
        required: false # Not required for scheduled runs
        type: string
      ref:
        description: 'The branch or ref (full git sha) to release from.'
        required: true
        type: string
        default: 'main'
      dry_run:
        description: 'Run a dry-run of the release process; no branches, npm packages or GitHub releases will be created.'
        required: true
        type: boolean
        default: true
      create_nightly_release:
        description: 'Auto apply the nightly release tag, input version is ignored.'
        required: false
        type: boolean
        default: false
      force_skip_tests:
        description: 'Select to skip the "Run Tests" step in testing. Prod releases should run tests'
        required: false
        type: boolean
        default: false

jobs:
  release:
    runs-on: ubuntu-latest
    environment:
      name: production-release
      url: ${{ github.server_url }}/${{ github.repository }}/releases/tag/${{ steps.version.outputs.RELEASE_TAG }}
    if: github.repository == 'acoliver/llxprt-code'
    permissions:
      contents: write
      packages: write
      id-token: write
      issues: write # For creating issues on failure
    outputs:
      RELEASE_TAG: ${{ steps.version.outputs.RELEASE_TAG }}

    steps:
      - name: Checkout code
        uses: actions/checkout@11bd71901bbe5b1630ceea73d27597364c9af683 # v4
        with:
          ref: ${{ github.sha }}
          fetch-depth: 0

      - name: Set booleans for simplified logic
        id: vars
        run: |
          is_nightly="false"
          if [[ "${{ github.event_name }}" == "schedule" || "${{ github.event.inputs.create_nightly_release }}" == "true" ]]; then
            is_nightly="true"
          fi
          echo "is_nightly=${is_nightly}" >> $GITHUB_OUTPUT

          is_dry_run="false"
          if [[ "${{ github.event.inputs.dry_run }}" == "true" ]]; then
            is_dry_run="true"
          fi
          echo "is_dry_run=${is_dry_run}" >> $GITHUB_OUTPUT

      - name: Setup Node.js
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: '24'
          cache: 'npm'

      - name: Install Dependencies
        run: npm ci

      - name: Get the version
        id: version
        run: |
          VERSION_JSON=$(node scripts/get-release-version.js)
          echo "RELEASE_TAG=$(echo $VERSION_JSON | jq -r .releaseTag)" >> $GITHUB_OUTPUT
          echo "RELEASE_VERSION=$(echo $VERSION_JSON | jq -r .releaseVersion)" >> $GITHUB_OUTPUT
          echo "NPM_TAG=$(echo $VERSION_JSON | jq -r .npmTag)" >> $GITHUB_OUTPUT
        env:
          IS_NIGHTLY: ${{ steps.vars.outputs.is_nightly }}
          MANUAL_VERSION: ${{ inputs.version }}

      - name: Run Preflight Checks
        if: github.event.inputs.force_skip_tests != 'true'
        run: node scripts/preflight-ci.js
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          OPENAI_BASE_URL: https://openrouter.ai/api/v1
          LLXPRT_DEFAULT_MODEL: google/gemini-2.5-flash
          LLXPRT_DEFAULT_PROVIDER: openai
          LLXPRT_AUTH_TYPE: none

      - name: Build Bundle for Integration Tests
        run: npm run bundle

      - name: Run Integration Tests
        if: github.event.inputs.force_skip_tests != 'true'
        run: |
          npm run test:integration:sandbox:none
          # Skipping Docker tests due to flakiness
          # npm run test:integration:sandbox:docker
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
          OPENAI_API_KEY: ${{ secrets.OPENROUTER_API_KEY }}
          OPENAI_BASE_URL: https://openrouter.ai/api/v1
          LLXPRT_DEFAULT_MODEL: google/gemini-2.5-flash
          LLXPRT_DEFAULT_PROVIDER: openai
          LLXPRT_AUTH_TYPE: none

      - name: Configure Git User
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Create and switch to a release branch
        id: release_branch
        run: |
          BRANCH_NAME="release/${{ steps.version.outputs.RELEASE_TAG }}"
          git switch -c $BRANCH_NAME
          echo "BRANCH_NAME=${BRANCH_NAME}" >> $GITHUB_OUTPUT

      - name: Update package versions
        run: |
          npm run release:version ${{ steps.version.outputs.RELEASE_VERSION }}

      - name: Commit and Conditionally Push package versions
        run: |
          git add package.json package-lock.json packages/*/package.json packages/*/package-lock.json
          git commit -m "chore(release): ${{ steps.version.outputs.RELEASE_TAG }}"
          if [[ "${{ steps.vars.outputs.is_dry_run }}" == "false" ]]; then
            echo "Pushing release branch to remote..."
            git push --set-upstream origin ${{ steps.release_branch.outputs.BRANCH_NAME }} --follow-tags
          else
            echo "Dry run enabled. Skipping push."
          fi

      - name: Build and Prepare Packages
        run: |
          rm -rf packages/*/dist
          npm run build:packages
          npm run bundle
          npm run prepare:package

      - name: Configure npm for publishing
        uses: actions/setup-node@49933ea5288caeca8642d1e84afbd3f7d6820020 # v4
        with:
          node-version: '24'
          registry-url: 'https://registry.npmjs.org/'
          scope: '@vybestack'

      - name: Publish @vybestack/llxprt-code-core
        run: npm publish --workspace=@vybestack/llxprt-code-core --tag=${{ steps.version.outputs.NPM_TAG }} ${{ steps.vars.outputs.is_dry_run == 'true' && '--dry-run' || '' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Install latest core package
        if: steps.vars.outputs.is_dry_run == 'false'
        run: npm install @vybestack/llxprt-code-core@${{ steps.version.outputs.RELEASE_VERSION }} --workspace=@vybestack/llxprt-code --save-exact

      - name: Publish @vybestack/llxprt-code
        run: npm publish --workspace=@vybestack/llxprt-code --tag=${{ steps.version.outputs.NPM_TAG }} ${{ steps.vars.outputs.is_dry_run == 'true' && '--dry-run' || '' }}
        env:
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}

      - name: Generate Release Notes with LLxprt Code
        id: release_notes
        run: |
          # Get the last release tag
          LAST_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
          
          if [ -z "$LAST_TAG" ]; then
            echo "No previous release tag found. Getting initial commit."
            LAST_TAG=$(git rev-list --max-parents=0 HEAD)
          fi
          
          echo "Generating release notes from $LAST_TAG to HEAD"
          
          # Get all commits since last tag
          COMMIT_MESSAGES=$(git log --pretty=format:"- %s (%h)" $LAST_TAG..HEAD | head -100)
          
          # Get list of modified files for categorization
          FILES_CHANGED=$(git diff --name-only $LAST_TAG..HEAD | grep -E "\.(ts|js|json|yml)" | head -50)
          
          # Count commits by category (simple pattern matching)
          LLXPRT_COMMITS=$(git log --oneline $LAST_TAG..HEAD | grep -iE "(llxprt|multi-provider|vybestack|qwen|openai|anthropic|groq|cohere|together)" | wc -l)
          UPSTREAM_COMMITS=$(git log --oneline $LAST_TAG..HEAD | grep -iE "(gemini|google|upstream|sync|merge upstream)" | wc -l)
          BUG_FIXES=$(git log --oneline $LAST_TAG..HEAD | grep -iE "(fix|bug|error|issue|resolve)" | wc -l)
          
          # Generate the release notes using LLxprt Code
          set +e  # Don't exit on error
          RELEASE_NOTES=$(npx @vybestack/llxprt-code@latest \
            --no-interactive \
            --provider gemini \
            --model gemini-2.5-pro \
            --key "${{ secrets.GEMINI_API_KEY }}" \
            --prompt "$(cat <<'PROMPT_EOF'
          Generate professional release notes for LLxprt Code ${{ steps.version.outputs.RELEASE_TAG }}. 
          
          Context: LLxprt Code is a multi-provider AI code assistant forked from gemini-cli. It supports multiple AI providers (Gemini, OpenAI, Anthropic, Groq, Cohere, Together, Qwen) while gemini-cli only supports Google's Gemini.
          
          Commits since last release:
          $COMMIT_MESSAGES
          
          Statistics:
          - LLxprt-specific commits: $LLXPRT_COMMITS
          - Upstream sync commits: $UPSTREAM_COMMITS  
          - Bug fixes: $BUG_FIXES
          
          Files changed include:
          $FILES_CHANGED
          
          Create release notes with these sections:
          
          ## ðŸŽ¯ Release Focus
          [1-2 sentences summarizing the main theme of this release]
          
          ## âœ¨ LLxprt-Specific Features
          [Bullet points of new features unique to LLxprt, especially multi-provider support enhancements]
          
          ## ðŸ› Bug Fixes
          [Bullet points of significant bug fixes]
          
          ## ðŸ“¦ Upstream Updates
          [Features and fixes incorporated from gemini-cli upstream, if any]
          
          ## ðŸ“¥ Installation & Upgrade
          
          ### Install
          \`\`\`bash
          npm install -g @vybestack/llxprt-code
          \`\`\`
          
          ### Upgrade
          \`\`\`bash
          npm update -g @vybestack/llxprt-code
          \`\`\`
          
          ### Quick Start
          \`\`\`bash
          # Configure your preferred provider
          llxprt config set provider [gemini|openai|anthropic|groq|cohere|together|qwen]
          llxprt config set key YOUR_API_KEY
          
          # Start using LLxprt Code
          llxprt "help me with my code"
          \`\`\`
          
          Keep it concise but informative. Focus on what matters to users.
          PROMPT_EOF
          )" 2>&1)
          LLXPRT_EXIT_CODE=$?
          set -e
          
          if [ $LLXPRT_EXIT_CODE -ne 0 ] || [ -z "$RELEASE_NOTES" ]; then
            echo "Failed to generate release notes with LLxprt Code (exit code: $LLXPRT_EXIT_CODE)"
            echo "Falling back to basic release notes..."
            
            # Generate basic fallback release notes
            RELEASE_NOTES=$(cat <<'FALLBACK_EOF'
## Release ${{ steps.version.outputs.RELEASE_TAG }}

### Changes since last release

Please see the commit history for changes.

### Installation & Upgrade

#### Install
```bash
npm install -g @vybestack/llxprt-code
```

#### Upgrade
```bash
npm update -g @vybestack/llxprt-code
```
FALLBACK_EOF
            )
          fi
          
          # Save release notes to file and output
          echo "$RELEASE_NOTES" > release-notes.md
          
          # Also save to GitHub output for use in release creation
          {
            echo 'release_notes<<EOF'
            echo "$RELEASE_NOTES"
            echo 'EOF'
          } >> $GITHUB_OUTPUT
          
          echo "Release notes generated successfully"
          
          # Display release notes in the job summary for dry runs
          if [[ "${{ steps.vars.outputs.is_dry_run }}" == "true" ]]; then
            echo "## ðŸ“ Generated Release Notes" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "$RELEASE_NOTES" >> $GITHUB_STEP_SUMMARY
          fi

      - name: Create GitHub Release and Tag
        if: ${{ steps.vars.outputs.is_dry_run == 'false' }}
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RELEASE_BRANCH: ${{ steps.release_branch.outputs.BRANCH_NAME }}
        run: |
          # Use the generated release notes
          gh release create ${{ steps.version.outputs.RELEASE_TAG }} \
            bundle/llxprt.js \
            --target "$RELEASE_BRANCH" \
            --title "Release ${{ steps.version.outputs.RELEASE_TAG }}" \
            --notes "${{ steps.release_notes.outputs.release_notes }}"

      - name: Create Issue on Failure
        if: failure()
        run: |
          gh issue create \
            --title "Release Failed for ${{ steps.version.outputs.RELEASE_TAG || 'N/A' }} on $(date +'%Y-%m-%d')" \
            --body "The release workflow failed. See the full run for details: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}" \
            --label "kind/bug,release-failure"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
