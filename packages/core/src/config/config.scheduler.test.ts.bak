/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { describe, it, expect, beforeEach, afterEach, vi, beforeAll } from 'vitest';
import { Config } from './config.js';

// Use dynamic import to avoid circular dependencies with Config
let CoreToolScheduler: any;
let OutputUpdateHandler: any;
let AllToolCallsCompleteHandler: any;
let ToolCallsUpdateHandler: any;

beforeAll(async () => {
  const schedulerModule = await import('../core/coreToolScheduler.js');
  CoreToolScheduler = schedulerModule.CoreToolScheduler;
  OutputUpdateHandler = schedulerModule.OutputUpdateHandler;
  AllToolCallsCompleteHandler = schedulerModule.AllToolCallsCompleteHandler;
  ToolCallsUpdateHandler = schedulerModule.ToolCallsUpdateHandler;
});

describe('Config - CoreToolScheduler Singleton', () => {
  let config: Config;
  const testSessionId = 'test-session-123';

  beforeEach(async () => {
    // Create a minimal Config instance for testing
    const mockSettingsService = {
      get: vi.fn(),
      set: vi.fn(),
      getAllGlobalSettings: vi.fn(() => ({})),
      getProviderSettings: vi.fn(() => ({})),
      setProviderSetting: vi.fn(),
      clear: vi.fn(),
    };

    const configParams = {
      sessionId: testSessionId,
      targetDir: process.cwd(),
      debugMode: false,
      cwd: process.cwd(),
      model: 'gemini-pro',
      settingsService: mockSettingsService as any,
      eventEmitter: undefined,
    };

    config = new Config(configParams);
    await config.initialize();

    // Clear any existing scheduler instances from previous tests
    (config as any).schedulerInstances?.clear();
    (config as any).schedulerCallbacks?.clear();
  });

  afterEach(() => {
    // Clean up schedulers created by tests
    const schedulerInstances = (config as any).schedulerInstances as
      | Map<string, CoreToolScheduler>
      | undefined;
    if (schedulerInstances) {
      for (const scheduler of schedulerInstances.values()) {
        scheduler.dispose();
      }
      schedulerInstances.clear();
    }
    (config as any).schedulerCallbacks?.clear();
  });

  describe('getOrCreateScheduler', () => {
    it('should create a new scheduler instance for a given sessionId if none exists', async () => {
      const callbacks = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const scheduler1 = await await config.getOrCreateScheduler(testSessionId, callbacks);

      expect(scheduler1).toBeInstanceOf(CoreToolScheduler);
      expect(scheduler1).toBeDefined();

      // Verify it was stored in the map
      const schedulerInstances = (config as any)
        .schedulerInstances as Map<string, CoreToolScheduler>;
      expect(schedulerInstances?.has(testSessionId)).toBe(true);
      expect(schedulerInstances?.get(testSessionId)).toBe(scheduler1);
    });

    it('should return the same scheduler instance for the same sessionId', () => {
      const callbacks1 = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const callbacks2 = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const scheduler1 = await config.getOrCreateScheduler(testSessionId, callbacks1);
      const scheduler2 = await config.getOrCreateScheduler(testSessionId, callbacks2);

      expect(scheduler1).toBe(scheduler2);
      expect(scheduler1).toBe(scheduler2);

      // Verify only one scheduler in the map
      const schedulerInstances = (config as any)
        .schedulerInstances as Map<string, CoreToolScheduler>;
      expect(schedulerInstances?.size).toBe(1);
      expect(schedulerInstances?.get(testSessionId)).toBe(scheduler1);
    });

    it('should create different scheduler instances for different sessionIds', () => {
      const otherSessionId = 'other-session-456';

      const callbacks = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const scheduler1 = await config.getOrCreateScheduler(testSessionId, callbacks);
      const scheduler2 = await config.getOrCreateScheduler(otherSessionId, callbacks);

      expect(scheduler1).not.toBe(scheduler2);

      // Verify both schedulers are in the map
      const schedulerInstances = (config as any)
        .schedulerInstances as Map<string, CoreToolScheduler>;
      expect(schedulerInstances?.size).toBe(2);
      expect(schedulerInstances?.get(testSessionId)).toBe(scheduler1);
      expect(schedulerInstances?.get(otherSessionId)).toBe(scheduler2);
    });

    it('should store callbacks for each component that requests a scheduler', () => {
      const callbacks1 = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const callbacks2 = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      await config.getOrCreateScheduler(testSessionId, callbacks1);
      await config.getOrCreateScheduler(testSessionId, callbacks2);

      const schedulerCallbacks = (config as any)
        .schedulerCallbacks as Map<string, any[]>;
      expect(schedulerCallbacks?.has(testSessionId)).toBe(true);

      const callbacksForSession = schedulerCallbacks?.get(testSessionId) ?? [];
      expect(callbacksForSession).toHaveLength(2);
      expect(callbacksForSession).toContain(callbacks1);
      expect(callbacksForSession).toContain(callbacks2);
    });
  });

  describe('disposeScheduler', () => {
    it('should dispose and remove the scheduler for a given sessionId', () => {
      const callbacks = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const scheduler = await config.getOrCreateScheduler(testSessionId, callbacks);

      // Verify scheduler exists
      const schedulerInstancesBefore = (config as any)
        .schedulerInstances as Map<string, CoreToolScheduler>;
      expect(schedulerInstancesBefore?.has(testSessionId)).toBe(true);

      // Dispose
      config.disposeScheduler(testSessionId);

      // Verify scheduler was removed
      const schedulerInstancesAfter = (config as any)
        .schedulerInstances as Map<string, CoreToolScheduler>;
      expect(schedulerInstancesAfter?.has(testSessionId)).toBe(false);

      // Verify callbacks were also removed
      const schedulerCallbacksAfter = (config as any)
        .schedulerCallbacks as Map<string, any[]>;
      expect(schedulerCallbacksAfter?.has(testSessionId)).toBe(false);
    });

    it('should not throw if disposing a non-existent scheduler', () => {
      const nonExistentSessionId = 'non-existent-session';

      expect(() => {
        config.disposeScheduler(nonExistentSessionId);
      }).not.toThrow();
    });

    it('should properly dispose the scheduler instance', () => {
      const callbacks = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const scheduler = await config.getOrCreateScheduler(testSessionId, callbacks);

      // Spy on the dispose method
      const disposeSpy = vi.spyOn(scheduler, 'dispose');

      config.disposeScheduler(testSessionId);

      expect(disposeSpy).toHaveBeenCalled();
    });
  });

  describe('Integration: Single scheduler per session', () => {
    it('should ensure only one CoreToolScheduler instance exists per sessionId across multiple components', () => {
      const component1Callbacks = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const component2Callbacks = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const schedulerFromComponent1 = await config.getOrCreateScheduler(
        testSessionId,
        component1Callbacks,
      );
      const schedulerFromComponent2 = await config.getOrCreateScheduler(
        testSessionId,
        component2Callbacks,
      );

      // Both components get the same scheduler instance
      expect(schedulerFromComponent1).toBe(schedulerFromComponent2);

      // Verify only one scheduler in the map
      const schedulerInstances = (config as any)
        .schedulerInstances as Map<string, CoreToolScheduler>;
      expect(schedulerInstances?.size).toBe(1);
    });

    it('should handle multiple sessions with separate schedulers', () => {
      const sessions = ['session-1', 'session-2', 'session-3'];
      const callbacks = {
        outputUpdateHandler: vi.fn() as OutputUpdateHandler,
        onAllToolCallsComplete: vi.fn() as AllToolCallsCompleteHandler,
        onToolCallsUpdate: vi.fn() as ToolCallsUpdateHandler,
        getPreferredEditor: () => undefined,
        onEditorClose: vi.fn(),
      };

      const schedulers: CoreToolScheduler[] = [];

      for (const sessionId of sessions) {
        schedulers.push(await config.getOrCreateScheduler(sessionId, callbacks));
      }

      // All schedulers should be different
      expect(schedulers[0]).not.toBe(schedulers[1]);
      expect(schedulers[1]).not.toBe(schedulers[2]);
      expect(schedulers[0]).not.toBe(schedulers[2]);

      // Verify correct number of schedulers in map
      const schedulerInstances = (config as any)
        .schedulerInstances as Map<string, CoreToolScheduler>;
      expect(schedulerInstances?.size).toBe(3);
    });
  });
});
