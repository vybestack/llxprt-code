# Gemini OAuth Fallback Dialog Research

## Executive Summary

This document provides implementation guidance for adding a fallback dialog mechanism to the Gemini OAuth flow, modeled after the existing Anthropic OAuth implementation.

## Current Gemini OAuth Flow

### Location
- **CLI Provider**: `packages/cli/src/auth/gemini-oauth-provider.ts`
- **Core OAuth**: `packages/core/src/code_assist/oauth2.ts`

### How `initiateAuth()` Works (Gemini)

The Gemini OAuth flow in `gemini-oauth-provider.ts` (lines 200-280):

1. **Imports Core Module**: Dynamically imports `@vybestack/llxprt-code-core`
2. **Gets OAuth Client**: Calls `getOauthClient(AuthType.GEMINI, config)`
3. **Returns OAuth Client**: The client from `oauth2.ts` handles the entire flow internally

**Key Issue**: The Gemini provider delegates ALL OAuth logic to `oauth2.ts`, which:
- Automatically starts a local HTTP server on a random port
- Generates the authorization URL internally
- Opens the browser automatically
- Handles the callback internally
- **Does NOT expose the authorization URL to the CLI layer**

### Core OAuth Flow (`oauth2.ts`)

The actual OAuth happens in `authWithWeb()` function (lines 353-500):

```typescript
async function authWithWeb(client: OAuth2Client): Promise<OauthWebLogin> {
  const port = await getAvailablePort();
  const host = process.env.OAUTH_CALLBACK_HOST || 'localhost';
  const redirectUri = `http://localhost:${port}/oauth2callback`;
  const state = crypto.randomBytes(32).toString('hex');
  
  // THIS IS THE URL WE NEED TO EXTRACT
  const authUrl = client.generateAuthUrl({
    redirect_uri: redirectUri,
    scope: [
      'https://www.googleapis.com/auth/cloud-platform',
      'https://www.googleapis.com/auth/userinfo.profile',
      'https://www.googleapis.com/auth/userinfo.email',
    ],
    state: state,
    access_type: 'offline',
    prompt: 'consent',
    code_challenge: codeChallenge,
    code_challenge_method: CodeChallengeMethod.S256,
  });

  // Browser is opened here
  await open(authUrl);
  
  // Local server waits for callback
  return new Promise((resolve, reject) => {
    const server = http.createServer(async (req, res) => {
      // Handles callback with ?code=XXX&state=YYY
    });
    server.listen(port, host);
  });
}
```

**Critical Components**:
- **Authorization URL**: Generated by `client.generateAuthUrl()` from `google-auth-library`
- **Callback Server**: Local HTTP server on `http://localhost:{port}/oauth2callback`
- **Code/State**: OAuth returns `?code=XXX&state=YYY` to the callback URL
- **PKCE**: Uses S256 code challenge/verifier for security

### What the User Needs to Paste Back

In the Google OAuth flow, the user receives a **full callback URL** like:
```
http://localhost:8765/oauth2callback?code=4/0AY0e-g7...&state=abc123...&scope=https://...
```

**Required from User**: The entire query string or just the `code` parameter value.

The current `oauth2.ts` extracts it like this (lines 390-420):
```typescript
const query = url.parse(req.url || '', true).query;
const code = query.code as string | undefined;
const receivedState = query.state as string | undefined;
```

## Anthropic OAuth Flow (Working Fallback Pattern)

### Location
`packages/cli/src/auth/anthropic-oauth-provider.ts`

### How It Works (lines 200-350)

1. **Device Code Flow**: Anthropic uses OAuth 2.0 Device Code flow
2. **Gets Verification URL**: Receives `verification_uri_complete` from API
3. **Local Callback Setup** (optional): Attempts to start local server
4. **Shows URL in UI**: **ALWAYS displays URL first, before browser launch**
5. **Attempts Browser**: Tries to open browser (may fail)
6. **Waits for Code**: Sets up promise to wait for user input

**Key Implementation** (lines 225-245):
```typescript
const message = `Please authorize with Anthropic by visiting:\n${authUrl}`;
const historyItem: HistoryItemOAuthURL = {
  type: 'oauth_url',
  text: message,
  url: authUrl,
};

// Add to UI
const addItem = this.addItem || globalOAuthUI.getAddItem();
if (addItem) {
  addItem(historyItem, Date.now());
}

// Console fallback
console.log('Visit the following URL to authorize:');
console.log(authUrl);

// Copy to clipboard
await ClipboardService.copyToClipboard(authUrl);

// Try browser
if (shouldLaunchBrowser()) {
  try {
    await openBrowserSecurely(authUrl);
  } catch (error) {
    this.logger.debug(() => `Browser launch error: ${error}`);
  }
}

// Wait for callback OR manual code entry
if (localCallback) {
  const { code, state } = await localCallback.waitForCallback();
  await this.completeAuth(`${code}#${state}`);
} else {
  // Fallback: wait for user to paste code
  this.pendingAuthPromise = new Promise<string>((resolve, reject) => {
    this.authCodeResolver = resolve;
    this.authCodeRejecter = reject;
    setTimeout(() => reject(new Error('timeout')), 5 * 60 * 1000);
  });
  
  const authCode = await this.pendingAuthPromise;
  await this.completeAuth(authCode);
}
```

**Key Methods**:
- `setAddItem()`: Receives UI callback function (lines 96-104)
- `waitForAuthCode()`: Creates promise for manual code entry (lines 109-116)
- `submitAuthCode(code)`: Resolves promise when user pastes code (lines 121-127)
- `cancelAuth()`: Rejects promise if user cancels (lines 132-141)

### UI Components

**Type Definition** (`packages/cli/src/ui/types.ts`, lines 85-90):
```typescript
export type HistoryItemOAuthURL = HistoryItemBase & {
  type: 'oauth_url';
  text: string;
  url: string;
};
```

**Display Component** (`packages/cli/src/ui/components/messages/OAuthUrlMessage.tsx`):
- Shows formatted OAuth URL message
- Creates OSC 8 hyperlink for clickable terminal links
- Displays instructions for manual copy-paste
- Shows URL in monospace font for easy selection

**History Display** (`packages/cli/src/ui/components/HistoryItemDisplay.tsx`):
```typescript
case 'oauth_url':
  return (
    <OAuthUrlMessage
      text={item.text}
      url={item.url}
    />
  );
```

## Implementation Guidance for Gemini OAuth Fallback

### Challenge: Architecture Mismatch

**Problem**: The Anthropic flow uses Device Code OAuth which naturally provides a URL upfront. The Gemini flow uses Authorization Code OAuth with a local callback server, where the URL is generated deep in `oauth2.ts` and never exposed.

### Solution Approaches

#### Option 1: Modify Core OAuth to Expose URL (Recommended)

**Modify `packages/core/src/code_assist/oauth2.ts`**:

1. **Change `authWithWeb()` return type** to include the URL:
```typescript
interface OauthWebLogin {
  authUrl: string;  // ADD THIS
  server: http.Server;
  port: number;
  redirectUri: string;
  state: string;
  codeVerifier: string;
}

async function authWithWeb(client: OAuth2Client): Promise<OauthWebLogin> {
  // ... existing code to generate authUrl ...
  
  return {
    authUrl,  // EXPOSE THIS
    server,
    port,
    redirectUri,
    state,
    codeVerifier,
  };
}
```

2. **Modify `getOauthClient()`** to return the URL or handle it via callback:
```typescript
export async function getOauthClient(
  authType: AuthType,
  config: Config,
  onAuthUrl?: (url: string) => Promise<void>,  // ADD CALLBACK
): Promise<OAuth2Client> {
  // ... existing code ...
  
  const { authUrl, server, redirectUri, state, codeVerifier } = await authWithWeb(client);
  
  // Call the callback if provided
  if (onAuthUrl) {
    await onAuthUrl(authUrl);
  }
  
  // ... rest of flow ...
}
```

3. **Handle Manual Code Entry**: Add fallback for when local callback fails:
```typescript
// After timeout or server error, allow manual code entry
if (manualCodeEntry) {
  const code = await getManualCode();  // Wait for user input
  return await authWithCode(client, code, codeVerifier, redirectUri);
}
```

#### Option 2: Extract Local Callback Logic to CLI Layer

**Create new module**: `packages/cli/src/auth/gemini-local-oauth.ts`

1. **Replicate `authWithWeb()` logic** at CLI level
2. **Generate URL** and expose it to UI
3. **Manage local callback server** in CLI
4. **Call core `authWithCode()`** after receiving code

**Pros**: 
- Clean separation
- More control at CLI level
- Easier to add fallback

**Cons**:
- Code duplication
- Must maintain parity with core oauth2.ts

#### Option 3: Hybrid Approach (Best Balance)

**In `packages/core/src/code_assist/oauth2.ts`**:

1. **Export `startOAuthServer()` function**:
```typescript
export async function startOAuthServer(
  client: OAuth2Client,
): Promise<{
  authUrl: string;
  waitForCode: () => Promise<{ code: string; state: string }>;
  manualAuth: (code: string, state: string) => Promise<void>;
  shutdown: () => void;
}> {
  const port = await getAvailablePort();
  const redirectUri = `http://localhost:${port}/oauth2callback`;
  const state = crypto.randomBytes(32).toString('hex');
  const codeVerifier = crypto.randomBytes(32).toString('base64url');
  
  const authUrl = client.generateAuthUrl({
    redirect_uri: redirectUri,
    scope: [
      'https://www.googleapis.com/auth/cloud-platform',
      'https://www.googleapis.com/auth/userinfo.profile',
      'https://www.googleapis.com/auth/userinfo.email',
    ],
    state: state,
    access_type: 'offline',
    prompt: 'consent',
    code_challenge: crypto
      .createHash('sha256')
      .update(codeVerifier)
      .digest('base64url'),
    code_challenge_method: CodeChallengeMethod.S256,
  });
  
  let codeResolver: (value: { code: string; state: string }) => void;
  let codeRejecter: (error: Error) => void;
  
  const codePromise = new Promise<{ code: string; state: string }>(
    (resolve, reject) => {
      codeResolver = resolve;
      codeRejecter = reject;
    },
  );
  
  const server = http.createServer(async (req, res) => {
    const query = url.parse(req.url || '', true).query;
    const code = query.code as string | undefined;
    const receivedState = query.state as string | undefined;
    
    if (code && receivedState === state) {
      res.writeHead(200, { 'Content-Type': 'text/html' });
      res.end('<html><body><h1>Authorization successful!</h1><p>You can close this window.</p></body></html>');
      codeResolver({ code, state: receivedState });
    } else {
      res.writeHead(400);
      res.end('Invalid authorization');
      codeRejecter(new Error('Invalid authorization response'));
    }
  });
  
  server.listen(port, 'localhost');
  
  return {
    authUrl,
    waitForCode: () => codePromise,
    manualAuth: async (code: string, receivedState: string) => {
      if (receivedState === state) {
        await authWithCode(client, code, codeVerifier, redirectUri);
      } else {
        throw new Error('State mismatch');
      }
    },
    shutdown: () => {
      server.close();
      codeRejecter(new Error('Server shutdown'));
    },
  };
}
```

**In `packages/cli/src/auth/gemini-oauth-provider.ts`**:

```typescript
async initiateAuth(): Promise<void> {
  await this.ensureInitialized();

  return this.errorHandler.wrapMethod(
    async () => {
      const coreModule = await import('@vybestack/llxprt-code-core');
      const { getBasicOAuthClient, startOAuthServer } = coreModule;
      
      // Get OAuth client without starting full flow
      const client = await getBasicOAuthClient();
      
      // Start OAuth server and get URL
      const oauth = await startOAuthServer(client);
      
      // Show URL in UI (SAME AS ANTHROPIC)
      const message = `Please authorize with Google by visiting:\n${oauth.authUrl}`;
      const historyItem: HistoryItemOAuthURL = {
        type: 'oauth_url',
        text: message,
        url: oauth.authUrl,
      };
      
      const addItem = this.addItem || globalOAuthUI.getAddItem();
      if (addItem) {
        addItem(historyItem, Date.now());
      }
      
      console.log('Visit the following URL to authorize:');
      console.log(oauth.authUrl);
      
      // Copy to clipboard
      try {
        await ClipboardService.copyToClipboard(oauth.authUrl);
      } catch (error) {
        console.debug('Failed to copy URL to clipboard:', error);
      }
      
      // Try browser
      if (shouldLaunchBrowser()) {
        try {
          await openBrowserSecurely(oauth.authUrl);
        } catch (error) {
          this.logger.debug(() => `Browser launch error: ${error}`);
        }
      }
      
      // Wait for callback OR manual entry
      try {
        const { code, state } = await Promise.race([
          oauth.waitForCode(),
          this.waitForManualCode(),
        ]);
        
        await oauth.manualAuth(code, state);
        await oauth.shutdown();
        
        // Success - token is now in OAuth client
        return;
      } catch (error) {
        await oauth.shutdown();
        throw error;
      }
    },
    this.name,
    'initiateAuth',
  );
}

// Add same methods as Anthropic provider
private manualCodeResolver?: (value: { code: string; state: string }) => void;
private manualCodeRejecter?: (error: Error) => void;

waitForManualCode(): Promise<{ code: string; state: string }> {
  return new Promise((resolve, reject) => {
    this.manualCodeResolver = resolve;
    this.manualCodeRejecter = reject;
    
    setTimeout(() => {
      reject(new Error('Manual code entry timed out'));
    }, 5 * 60 * 1000);
  });
}

submitAuthCode(code: string): void {
  if (this.manualCodeResolver) {
    // Parse code - user might paste full URL or just code
    const parsedCode = this.parseAuthResponse(code);
    this.manualCodeResolver(parsedCode);
    this.manualCodeResolver = undefined;
    this.manualCodeRejecter = undefined;
  }
}

private parseAuthResponse(input: string): { code: string; state: string } {
  // Handle full URL: http://localhost:8765/oauth2callback?code=XXX&state=YYY
  if (input.includes('oauth2callback')) {
    const parsedUrl = new URL(input);
    const code = parsedUrl.searchParams.get('code');
    const state = parsedUrl.searchParams.get('state');
    if (code && state) {
      return { code, state };
    }
  }
  
  // Handle query string: ?code=XXX&state=YYY
  if (input.includes('code=')) {
    const params = new URLSearchParams(input.replace(/^\?/, ''));
    const code = params.get('code');
    const state = params.get('state');
    if (code && state) {
      return { code, state };
    }
  }
  
  throw new Error('Invalid authorization response format');
}

cancelAuth(): void {
  if (this.manualCodeRejecter) {
    this.manualCodeRejecter(new Error('Authentication cancelled by user'));
    this.manualCodeResolver = undefined;
    this.manualCodeRejecter = undefined;
  }
}
```

### User Instructions

When showing the OAuth URL dialog, provide these instructions:

**If browser opens automatically**:
- "Your browser should open automatically"
- "After authorizing, you'll be redirected back to the application"
- "If redirect fails, copy the final URL from your browser's address bar and paste it here"

**If browser fails to open**:
- "Click the link above to authorize in your browser"
- "After authorizing, you will be redirected to a localhost URL"
- "If redirect fails, copy the entire URL from your browser's address bar (starting with http://localhost:...)"
- "Paste the URL here and press Enter"

**Expected format**:
```
http://localhost:8765/oauth2callback?code=4/0AY0e-g7XXXX&state=abc123YYYY&scope=https://...
```

### Testing Strategy

1. **Test with working local callback**: Ensure existing flow still works
2. **Test with blocked localhost**: Block port to simulate firewall/network issue
3. **Test with NO_BROWSER=true**: Verify manual flow works
4. **Test URL parsing**: Various formats (full URL, query string, code only)
5. **Test timeout**: Verify timeout after 5 minutes
6. **Test cancellation**: User cancels auth
7. **Test clipboard**: Verify URL copies to clipboard
8. **Test UI display**: Verify OAuthUrlMessage renders correctly

## Summary of Changes Required

### Core Changes (`packages/core/src/code_assist/oauth2.ts`)

1. **Export `startOAuthServer()` function** - New public API
2. **Export `getBasicOAuthClient()` helper** - Returns OAuth2Client without starting flow
3. **Keep existing `getOauthClient()` working** - Backward compatibility

### CLI Changes (`packages/cli/src/auth/gemini-oauth-provider.ts`)

1. **Add `submitAuthCode()` method** - Like Anthropic provider
2. **Add `cancelAuth()` method** - Like Anthropic provider
3. **Add `parseAuthResponse()` helper** - Parse various input formats
4. **Modify `initiateAuth()`** - Use new core API, show URL, handle fallback
5. **Add promise resolvers** - For manual code entry

### UI Changes

**NO CHANGES NEEDED** - Existing components already support `oauth_url` type:
- `HistoryItemOAuthURL` type exists
- `OAuthUrlMessage` component exists
- `HistoryItemDisplay` handles the type

## Implementation Priority

1. **Phase 1**: Modify core `oauth2.ts` to export `startOAuthServer()`
2. **Phase 2**: Update `gemini-oauth-provider.ts` to use new API
3. **Phase 3**: Add manual code entry methods
4. **Phase 4**: Add URL parsing logic
5. **Phase 5**: Test all scenarios

## Security Considerations

1. **PKCE**: Must maintain code_verifier/code_challenge for security
2. **State parameter**: Must validate state to prevent CSRF
3. **Localhost only**: redirect_uri must be localhost (Google requirement)
4. **Timeout**: Manual flow should timeout after 5 minutes
5. **Single-use codes**: Authorization codes are single-use
6. **No code in logs**: Never log the authorization code

## References

- Anthropic provider: `packages/cli/src/auth/anthropic-oauth-provider.ts`
- Core OAuth: `packages/core/src/code_assist/oauth2.ts`
- UI types: `packages/cli/src/ui/types.ts`
- OAuth URL message: `packages/cli/src/ui/components/messages/OAuthUrlMessage.tsx`
- Google OAuth 2.0: https://developers.google.com/identity/protocols/oauth2/native-app
