# Reimplementation Plan: Right-Click Paste in Alternate Buffer Mode

**Upstream SHA**: `8877c8527`
**Upstream subject**: Right click to paste in Alternate Buffer mode (#13234)

## What This Does

In alternate buffer mode, standard paste (Ctrl+V / Cmd+V) may not work reliably in some terminals. This adds right-click as an alternative paste trigger using the `clipboardy` library to read from the system clipboard, with image paste preferred over text.

## Key Design Decisions

1. **`PASTE_CLIPBOARD_IMAGE` → `PASTE_CLIPBOARD`**: The command now handles both image and text paste, so the name broadens. This is a cross-file rename touching keyBindings.ts, keyMatchers.test.ts, InputPrompt.tsx, and the commandDescriptions/commandCategories constants.
2. **No `getOffset()` method on TextBuffer**: The standalone `logicalPosToOffset(lines, row, col)` is already exported and imported by InputPrompt.tsx — a wrapper is unnecessary overhead.
3. **`clipboardy.read()` failure handling**: Must be a silent no-op — Wayland, SSH sessions, headless environments, and missing clipboard utilities will cause `clipboardy.read()` to throw. Catch and ignore.
4. **Mouse handler conflict**: InputPrompt doesn't currently use `useMouse`. Other consumers (ScrollProvider, useMouseSelection) subscribe independently — the MouseProvider broadcasts to all subscribers, and each handler can return `true` to signal consumption. No conflict.
5. **Non-mouse terminal safety**: When mouse events are disabled (`mouseEventsEnabled=false`), MouseProvider doesn't attach a stdin listener, so the useMouse hook harmlessly does nothing. No degradation path needed beyond making `isActive` conditional.

## Cross-File `PASTE_CLIPBOARD_IMAGE` → `PASTE_CLIPBOARD` Rename

Grep results for files requiring update:

| File | Lines |
|------|-------|
| `packages/cli/src/config/keyBindings.ts` | L57 (enum), L200 (defaultKeyBindings), L312 (commandCategories), L372 (commandDescriptions) |
| `packages/cli/src/ui/keyMatchers.test.ts` | L69 (originalMatchers), L305 (testCases) |
| `packages/cli/src/ui/components/InputPrompt.tsx` | L694 (keyMatchers usage) |

## Implementation Order (TDD)

### Phase 1: Write Failing Tests

#### Step 1a. `packages/cli/src/ui/keyMatchers.test.ts` — Rename matcher tests

Update the test references from `PASTE_CLIPBOARD_IMAGE` to `PASTE_CLIPBOARD`:

- In the `originalMatchers` lookup table (L69), change key from `Command.PASTE_CLIPBOARD_IMAGE` to `Command.PASTE_CLIPBOARD`
- In the `testCases` array (L305), change `command: Command.PASTE_CLIPBOARD_IMAGE` to `command: Command.PASTE_CLIPBOARD`
- The test logic stays the same: Ctrl+V → match, plain V → no match

These tests will **fail** because `Command.PASTE_CLIPBOARD` doesn't exist yet.

#### Step 1b. `packages/cli/src/ui/components/InputPrompt.test.tsx` — Right-click paste tests

Add new test cases (failing, since the mouse handler and clipboardy integration don't exist yet):

1. **Right-click triggers paste — image preferred over text**: Mock `clipboardHasImage` → true, mock `saveClipboardImage` → returns a path. Simulate `right-release` mouse event. Verify `@<path>` is inserted into the buffer. Clipboardy.read should NOT be called.

2. **Right-click triggers text paste when no image**: Mock `clipboardHasImage` → false. Mock `clipboardy.read()` → returns `"hello world"`. Simulate `right-release` mouse event. Verify `"hello world"` is inserted into the buffer at the cursor offset.

3. **Right-click is no-op when `clipboardy.read()` fails**: Mock `clipboardHasImage` → false. Mock `clipboardy.read()` → throws Error (simulating Wayland/SSH/no clipboard). Simulate `right-release` mouse event. Verify buffer is unchanged, no crash.

4. **Right-click is no-op when component is not focused**: Set `focus=false`. Simulate `right-release` mouse event. Verify buffer is unchanged.

5. **Right-click is no-op when embedded shell is focused**: Set `isEmbeddedShellFocused=true`. Simulate `right-release` mouse event. Verify buffer is unchanged.

**Test implementation notes:**
- Mock `useMouse` hook (from `../hooks/useMouse.js`) to capture the handler callback, similar to how ScrollProvider.test.tsx mocks it
- Mock `clipboardy` as a module: `vi.mock('clipboardy', () => ({ default: { read: vi.fn() } }))`
- The mock for `clipboardUtils` already exists in the test file

### Phase 2: Minimal Implementation to Pass Tests

#### Step 2a. `packages/cli/package.json` — Add clipboardy dependency

```json
"clipboardy": "^4.0.0"
```

Use `^4.0.0` to match the version already used in `packages/ui/package.json`. Then run `npm install` from the workspace root.

#### Step 2b. `packages/cli/src/config/keyBindings.ts` — Rename enum + references

1. **Enum** (L57): `PASTE_CLIPBOARD_IMAGE = 'pasteClipboardImage'` → `PASTE_CLIPBOARD = 'pasteClipboard'`
2. **defaultKeyBindings** (L200): `[Command.PASTE_CLIPBOARD_IMAGE]` → `[Command.PASTE_CLIPBOARD]`
3. **commandCategories** (L312): `Command.PASTE_CLIPBOARD_IMAGE` → `Command.PASTE_CLIPBOARD`
4. **commandDescriptions** (L372): Key `[Command.PASTE_CLIPBOARD_IMAGE]` → `[Command.PASTE_CLIPBOARD]`, update description text to `'Paste from the clipboard (image preferred, falls back to text).'`

#### Step 2c. `packages/cli/src/ui/components/InputPrompt.tsx` — Main changes

**Add imports:**
```typescript
import { useMouse } from '../hooks/useMouse.js';
import type { MouseEvent } from '../hooks/useMouse.js';
import clipboardy from 'clipboardy';
```

**Rename `handleClipboardImage` → `handleClipboardPaste`:**
- Keep existing image-paste logic intact (try image first)
- Add fallback: if no image found, try `await clipboardy.read()` for text
- If text obtained, insert at cursor using `logicalPosToOffset` (already imported) + `buffer.replaceRangeByOffset(offset, offset, text)`
- Wrap the entire `clipboardy.read()` call in try/catch — on failure, silently return (no-op)

```typescript
const handleClipboardPaste = useCallback(async () => {
  try {
    if (await clipboardHasImage()) {
      // ... existing image paste logic unchanged ...
      return;
    }
    // Fallback: try text paste
    try {
      const text = await clipboardy.read();
      if (text) {
        const offset = logicalPosToOffset(
          buffer.lines,
          buffer.cursor[0],
          buffer.cursor[1],
        );
        buffer.replaceRangeByOffset(offset, offset, text);
      }
    } catch {
      // Silent no-op: clipboard read can fail on Wayland, SSH, headless, etc.
    }
  } catch (error) {
    console.error('Error handling clipboard paste:', error);
  }
}, [buffer, config]);
```

**Update Ctrl+V handler reference** (L694):
```typescript
// Change: Command.PASTE_CLIPBOARD_IMAGE → Command.PASTE_CLIPBOARD
if (keyMatchers[Command.PASTE_CLIPBOARD](key)) {
  handleClipboardPaste();
  return;
}
```

Also update the dependency array reference from `handleClipboardImage` → `handleClipboardPaste`.

**Add mouse handler for right-click paste:**
```typescript
const handleMousePaste = useCallback(
  (event: MouseEvent) => {
    if (!focus || isEmbeddedShellFocused) return;
    if (event.name === 'right-release') {
      handleClipboardPaste();
    }
  },
  [focus, isEmbeddedShellFocused, handleClipboardPaste],
);

useMouse(handleMousePaste, { isActive: focus && !isEmbeddedShellFocused });
```

### Phase 3: Verify & Cleanup

#### Step 3a. Run all checks

```bash
npm run typecheck && npm run lint && npm run test
```

#### Step 3b. Manual verification

- Run LLxprt in alternate buffer mode
- Right-click to paste text — verify text appears at cursor
- Copy an image to clipboard, right-click — verify `@path` inserted
- Test with clipboard unavailable (e.g., SSH session) — verify no crash
- Ctrl+V should still work for image paste as before

## What NOT to Implement

- No changes to alternate buffer logic itself (already works)
- No changes to mouse mode toggle
- No `getOffset()` wrapper method on TextBuffer — use `logicalPosToOffset` directly
- No changes to `commandUtils.ts` — the existing `copyToClipboard` platform-specific code is unrelated to *reading* from clipboard and works fine as-is
