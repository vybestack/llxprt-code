# Phase 00a: Preflight Verification — COMPLETE

**Date:** 2026-02-16
**Plan:** PLAN-20250214-CREDPROXY
**Status:** ALL VERIFICATIONS PASS (with notes)

---

## 1. Dependency Verification

| Dependency | Status | Details |
|---|---|---|
| `net` (built-in) | [OK] PASS | Available via `require('net')` |
| `crypto` (built-in) | [OK] PASS | Available via `require('crypto')` |
| `os` (built-in) | [OK] PASS | Available via `require('os')` |
| `fs` (built-in) | [OK] PASS | Available via `require('fs')` |
| `google-auth-library` | [OK] PASS | v9.15.1 (direct dep of core), v10.5.0 (transitive via @google/genai) |
| `vitest` | [OK] PASS | v3.2.4, shared across all workspaces |
| `zod` | [OK] PASS | v3.25.76, shared across all workspaces |

---

## 2. Type/Interface Verification

### TokenStore Interface
- **Location:** `packages/core/src/auth/token-store.ts`
- **Status:** [OK] PASS — matches plan exactly

```typescript
export interface TokenStore {
  saveToken(provider: string, token: OAuthToken, bucket?: string): Promise<void>;
  getToken(provider: string, bucket?: string): Promise<OAuthToken | null>;
  removeToken(provider: string, bucket?: string): Promise<void>;
  listProviders(): Promise<string[]>;
  listBuckets(provider: string): Promise<string[]>;
  getBucketStats(provider: string, bucket: string): Promise<BucketStats | null>;
  acquireRefreshLock(provider: string, options?: { waitMs?: number; staleMs?: number; bucket?: string }): Promise<boolean>;
  releaseRefreshLock(provider: string, bucket?: string): Promise<void>;
}
```

### OAuthToken / OAuthTokenSchema
- **Location:** `packages/core/src/auth/types.ts`
- **Status:** [OK] PASS

```typescript
export const OAuthTokenSchema = z.object({
  access_token: z.string(),
  refresh_token: z.string().optional(),
  expiry: z.number(),           // Unix timestamp
  scope: z.string().nullable().optional(),
  token_type: z.enum(['Bearer', 'bearer']),
  resource_url: z.string().optional(),  // Qwen OAuth API endpoint
});
export type OAuthToken = z.infer<typeof OAuthTokenSchema>;
```

### BucketStats / BucketStatsSchema
- **Location:** `packages/core/src/auth/types.ts`
- **Status:** [OK] PASS

```typescript
export const BucketStatsSchema = z.object({
  bucket: z.string(),
  requestCount: z.number(),
  percentage: z.number(),
  lastUsed: z.number().optional(),  // Unix timestamp in milliseconds
});
export type BucketStats = z.infer<typeof BucketStatsSchema>;
```

### CodexOAuthTokenSchema
- **Location:** `packages/core/src/auth/types.ts`
- **Status:** [OK] PASS

```typescript
export const CodexOAuthTokenSchema = OAuthTokenSchema.extend({
  account_id: z.string().describe('Required for ChatGPT-Account-ID header'),
  id_token: z.string().optional().describe('JWT containing account claims'),
});
export type CodexOAuthToken = z.infer<typeof CodexOAuthTokenSchema>;
```

### KeyringTokenStore
- **Location:** `packages/core/src/auth/keyring-token-store.ts`
- **Status:** [OK] PASS — implements `TokenStore`
- **Constructor:** `constructor(options?: { secureStore?: SecureStore; lockDir?: string })`
- All methods match `TokenStore` interface exactly.

### ProviderKeyStorage
- **Location:** `packages/core/src/storage/provider-key-storage.ts`
- **Status:** [OK] PASS (with NOTE)
- **NOTE:** There is **no extracted interface** — `ProviderKeyStorage` is a concrete class only.

```typescript
export class ProviderKeyStorage {
  constructor(options?: { secureStore?: SecureStore })
  async saveKey(name: string, apiKey: string): Promise<void>
  async getKey(name: string): Promise<string | null>
  async deleteKey(name: string): Promise<boolean>
  async listKeys(): Promise<string[]>
  async hasKey(name: string): Promise<boolean>
}
```

Singleton pattern: `getProviderKeyStorage()` / `resetProviderKeyStorage()`

### OAuthProvider Interface
- **Location:** `packages/cli/src/auth/oauth-manager.ts` (line 185)
- **Status:** [OK] PASS

```typescript
export interface OAuthProvider {
  name: string;
  initiateAuth(): Promise<void>;
  getToken(): Promise<OAuthToken | null>;
  refreshToken(currentToken: OAuthToken): Promise<OAuthToken | null>;
  logout?(token?: OAuthToken): Promise<void>;
}
```

### AnthropicDeviceFlow
- **Location:** `packages/core/src/auth/anthropic-device-flow.ts`
- **Status:** WARNING: NOTE — discrepancy from plan

Plan assumed `initiateDeviceFlow()` and `exchangeCodeForToken()`. Actual signatures:

```typescript
export class AnthropicDeviceFlow {
  constructor(config?: Partial<AnthropicFlowConfig>)
  async initiateDeviceFlow(redirectUri?: string): Promise<DeviceCodeResponse>
  async exchangeCodeForToken(authCodeWithState: string): Promise<OAuthToken>
  getState(): string
  buildAuthorizationUrl(redirectUri: string): string
  async pollForToken(deviceCode: string): Promise<OAuthToken>
  async refreshToken(refreshToken: string): Promise<OAuthToken>
}
```

**Key difference:** `exchangeCodeForToken` takes a single `authCodeWithState: string` param (format: `code#state`), not separate code/state params.

### CodexDeviceFlow
- **Location:** `packages/core/src/auth/codex-device-flow.ts`
- **Status:** WARNING: NOTE — richer than plan assumed

```typescript
export class CodexDeviceFlow {
  constructor()
  buildAuthorizationUrl(redirectUri: string, state: string): string
  async exchangeCodeForToken(authCode: string, redirectUri: string, state: string): Promise<CodexOAuthToken>
  async refreshToken(refreshToken: string): Promise<CodexOAuthToken>
  async requestDeviceCode(): Promise<{ device_auth_id: string; user_code: string; interval: number }>
  async pollForDeviceToken(deviceAuthId: string, userCode: string, intervalSeconds?: number): Promise<{ authorization_code: string; code_verifier: string; code_challenge: string }>
  async completeDeviceAuth(authorizationCode: string, codeVerifier: string, redirectUri: string): Promise<CodexOAuthToken>
}
```

**Key difference:** Plan assumed `buildAuthorizationUrl()`, `requestDeviceCode()`, `exchangeCodeForToken()` — all present but signatures differ. `exchangeCodeForToken` takes `(authCode, redirectUri, state)`.

### QwenDeviceFlow
- **Location:** `packages/core/src/auth/qwen-device-flow.ts`
- **Status:** [OK] PASS

```typescript
export class QwenDeviceFlow {
  constructor(config: DeviceFlowConfig)
  async initiateDeviceFlow(): Promise<DeviceCodeResponse>
  async pollForToken(deviceCode: string): Promise<OAuthToken>
  async refreshToken(refreshToken: string): Promise<OAuthToken>
}
```

### mergeRefreshedToken
- **Location:** `packages/cli/src/auth/oauth-manager.ts` (line 78)
- **Status:** [OK] PASS — module-level function, not a class method

```typescript
type OAuthTokenWithExtras = OAuthToken & Record<string, unknown>;

function mergeRefreshedToken(
  currentToken: OAuthTokenWithExtras,
  refreshedToken: OAuthTokenWithExtras,
): OAuthTokenWithExtras
```

Used at 3 call sites within OAuthManager (lines 751, 1093, 1355).

### OAuthTokenWithExtras
- **Location:** `packages/cli/src/auth/oauth-manager.ts` (line 76)
- **Status:** [OK] PASS

```typescript
type OAuthTokenWithExtras = OAuthToken & Record<string, unknown>;
```

---

## 3. Call Path Verification

| Call Path | Status | Details |
|---|---|---|
| `new KeyringTokenStore` usage | [OK] PASS | Found in: `authCommand.ts` (L37, L659), `profileCommand.ts` (L100, L347), `providerManagerInstance.ts` (L242), `runtimeContextFactory.ts` (L263), plus several test files |
| `ProviderKeyStorage` usage | [OK] PASS | Used in `keyCommand.subcommands.test.ts` (L25, L66, L72, L86, etc.) with `getProviderKeyStorage()` singleton pattern |
| `mergeRefreshedToken` | [OK] PASS | Defined at line 78, used at lines 751, 1093, 1355 — all in `oauth-manager.ts` |
| `start_sandbox` | [OK] PASS | Defined at `packages/cli/src/utils/sandbox.ts:626`, mocked in gemini test at L98 |
| `tmpdir` in sandbox | [OK] PASS | Uses `fs.realpathSync(os.tmpdir())` at line 695 for macOS seatbelt — resolves symlinks |
| `scheduleProactiveRenewal` | [OK] PASS | Private method on OAuthManager (line 1231), `proactiveRenewals` Map (line 228) |
| `isBrowserLaunchSuppressed` | [OK] PASS | Method on Config class at `packages/core/src/config/config.ts:1527`, used in `oauth2.ts:133` |

---

## 4. Test Infrastructure Verification

| Item | Status | Details |
|---|---|---|
| vitest configs | [OK] PASS | Found in all packages: `vitest.config.ts`, plus specialized configs in cli (gemini, mutation, ci, integration) |
| Auth test files (core) | [OK] PASS | 10+ files: `qwen-device-flow.spec.ts`, `codex-device-flow.spec.ts`, `precedence.test.ts`, `keyring-token-store.test.ts`, etc. |
| OAuth test files (cli) | [OK] PASS | 10+ files: `oauth-manager.spec.ts`, `oauth-manager.issue1317.spec.ts`, `oauth-manager.logout.spec.ts`, etc. |

---

## 5. Blocking Issue Investigation

### Can `mergeRefreshedToken` be extracted without circular deps?
- **Status:** [OK] SAFE TO EXTRACT
- It's a **module-level function** (not a class method) at line 78 of `oauth-manager.ts`
- Dependencies: only `OAuthToken` type (from `@vybestack/llxprt-code-core` via `./types.js`)
- Uses `OAuthTokenWithExtras` type alias (also trivially extractable)
- No dependencies on `OAuthManager` class, `TokenStore`, or any cli-specific types
- **Resolution:** Can be moved to a standalone file (e.g., `token-merge.ts`) with zero circular dependency risk

### Does `ProviderKeyStorage` have an extracted interface?
- **Status:** [ERROR] NO INTERFACE EXISTS
- `ProviderKeyStorage` is a concrete class only — no separate interface
- **Resolution:** The credential proxy can either:
  1. Create a `ProviderKeyStorageInterface` and have the class implement it, OR
  2. Use TypeScript structural typing (duck typing) — since the proxy just needs the same method signatures
  3. Recommended: Create an interface for clean dependency inversion

### Gemini `authWithUserCode()` decomposition difficulty
- **Status:** WARNING: MODERATE COMPLEXITY
- `authWithUserCode()` at `packages/core/src/code_assist/oauth2.ts:259-397`
- It takes an `OAuth2Client` instance (from google-auth-library) and does:
  1. Generates PKCE via `client.generateCodeVerifierAsync()`
  2. Generates auth URL via `client.generateAuthUrl()`
  3. Clipboard copy + UI interaction via global hooks (`__oauth_wait_for_code`, `__oauth_add_item`)
  4. Readline fallback for non-interactive
  5. Calls `authWithCode(client, code, codeVerifier, redirectUri)` which calls `client.getToken()`
- **Key insight:** The `authWithCode()` function (line 616) is already exported separately!
- `authWithCode(client, code, codeVerifier, redirectUri)` signature: takes an `OAuth2Client`, auth code string, optional `{ codeVerifier: string }`, and redirect URI
- **Resolution:** The proxy doesn't need to decompose `authWithUserCode`. It only needs to:
  1. Call `initOauthClient(config)` to get the `OAuth2Client`
  2. Use `authWithCode(client, code, codeVerifier, redirectUri)` for code exchange
  3. The URL generation part can be replicated independently using `client.generateAuthUrl()`

### macOS `os.tmpdir()` symlink handling in sandbox.ts
- **Status:** [OK] ALREADY HANDLED
- Line 695: `TMP_DIR=${fs.realpathSync(os.tmpdir())}` — resolves `/var` → `/private/var` symlink
- The credential proxy socket should use the same `fs.realpathSync(os.tmpdir())` pattern
- Lines 1024-1025: Docker variant uses raw `os.tmpdir()` for volume mounts

### Existing `BucketStats` type shape
- **Status:** [OK] VERIFIED
```typescript
{
  bucket: string;
  requestCount: number;
  percentage: number;
  lastUsed?: number;  // Unix timestamp in milliseconds
}
```

---

## 6. Baseline Health Check

| Check | Status |
|---|---|
| `npm run typecheck` | [OK] PASS — all 4 workspaces clean (core, cli, a2a-server, test-utils) |
| `npm run test` | [OK] PASS — all test suites pass across all workspaces |

---

## Summary of Discrepancies from Plan

1. **AnthropicDeviceFlow.exchangeCodeForToken** — takes `authCodeWithState: string` (format: `code#state`), not separate params. Plan may need to account for this format.

2. **CodexDeviceFlow.exchangeCodeForToken** — takes `(authCode, redirectUri, state)`, 3 params not 2. Also has additional methods: `requestDeviceCode()`, `pollForDeviceToken()`, `completeDeviceAuth()`.

3. **ProviderKeyStorage** — no extracted interface exists. Need to create one or use structural typing.

4. **Gemini auth** — uses `google-auth-library`'s `OAuth2Client` which manages its own PKCE. The already-exported `authWithCode()` function can serve as the exchange entry point. No device flow per se — uses authorization code flow with PKCE.

## Blocking Issues: NONE

All discrepancies are minor and can be resolved during implementation. No blocking issues found. The codebase is in a healthy state for development.
