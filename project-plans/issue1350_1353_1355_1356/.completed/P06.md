# Phase 06: Implement SecureStore — COMPLETED

@plan PLAN-20260211-SECURESTORE.P06

## Summary

Replaced all stub methods in `packages/core/src/storage/secure-store.ts` with
real implementations. All 46 behavioral tests now pass.

## What Was Implemented

### Core Methods
- **Constructor**: Stores serviceName, fallbackDir (default `~/.llxprt/secure-store/{serviceName}`), fallbackPolicy, keytarLoader
- **getKeytar()**: Lazy-loads keytar adapter via keytarLoader, caches result, single attempt
- **defaultKeytarLoader()**: Dynamic `import('@napi-rs/keyring')`, wraps AsyncEntry in KeytarAdapter interface
- **isKeychainAvailable()**: Set-get-delete probe cycle. Caches `false` results for 60s TTL. Always re-probes for `true` (to detect mid-session failures). Probe cache invalidated after N consecutive keyring failures.
- **set(key, value)**: Validates key, tries keyring directly, falls back to encrypted file if keyring fails and policy allows
- **get(key)**: Tries keyring first (authoritative), falls back to encrypted file. Returns null if not found.
- **delete(key)**: Removes from BOTH keyring and fallback file. Returns true if either had it.
- **list()**: Combines findCredentials() from keyring + directory scan of `.enc` files, deduplicates, sorts. Skips probe accounts and malformed filenames.
- **has(key)**: Returns true if exists, false if NOT_FOUND, throws SecureStoreError with error taxonomy on other errors.

### Encrypted File Fallback
- AES-256-GCM encryption with async scrypt (N=16384, r=8, p=1)
- Machine-specific KDF: `SHA-256(hostname + username)` as machine ID
- Random 16-byte salt per file, random 12-byte IV per encryption
- Versioned envelope: `{"v":1, "crypto":{alg,kdf,N,r,p,saltLen}, "data":"<base64>"}`
- Atomic write: writeFile(tmp) → fsync → close → rename → chmod 0o600
- Directory creation with 0o700 permissions

### Key Validation
- Rejects keys containing `/`, `\`, null bytes
- Rejects `.` and `..` components
- Validation runs before ANY operation

### Error Taxonomy
- Maps errors to SecureStoreError with code (UNAVAILABLE, LOCKED, DENIED, CORRUPT, TIMEOUT, NOT_FOUND) + remediation strings
- classifyError() inspects error messages for classification

### Resilience
- Mid-session keyring failure falls back to encrypted file
- Consecutive keyring failure counter (threshold=3) invalidates probe cache
- Counter resets on successful keyring operation

## Design Decisions

1. **set()/get() try keyring directly** instead of calling isKeychainAvailable() first. This ensures consecutive failure tracking works correctly when keyring fails mid-session.
2. **Probe cache only honored for `false` results** within 60s TTL. `true` results always re-probe to detect transient failures.
3. **No scryptSync** — all key derivation uses async `crypto.scrypt` via Promise wrapper.

## Test Results

```
 [OK] src/storage/secure-store.test.ts (46 tests) 1415ms
 Tests  46 passed (46)
```

## Verification

- All 46 tests pass: `npx vitest run src/storage/secure-store.test.ts`
- Core package typechecks: `tsc --noEmit` (exit 0)
- No modifications to test file

## Completed

- Date: 2026-02-11
- Phase: P06
