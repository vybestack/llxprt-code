# REIMPLEMENT: 013f9848 — Extensions exitCli lifecycle + structural alignment

## Upstream Summary

Introduces consistent CLI lifecycle management for extension and MCP commands (28 files, 82 insertions). Creates `exitCli()` utility, adds `initializeOutputListenersAndFlush` middleware to the extensions command builder, and ensures all subcommands call `exitCli()` for clean shutdown.

## Why REIMPLEMENT

- LLxprt already has `runExitCleanup()` in `packages/cli/src/utils/cleanup.ts` — the foundation exists
- LLxprt has no `exitCli()` utility — extension commands call `process.exit(1)` directly (8 callsites)
- LLxprt has no `initializeOutputListenersAndFlush` (depends on Batch 10 stdout protection)
- Upstream adds +2 lines per command file — mechanical but touches every extension/MCP command
- LLxprt's MCP commands have similar pattern (at least `mcp/add.ts` calls `process.exit(1)`)
- We want to match upstream's structure for future compatibility

## Dependencies

- **Batch 10 (d1e35f86) MUST be applied first** — stdout protection creates the output listener infrastructure
- After d1e35f86, `initializeOutputListenersAndFlush` will exist (or equivalent)

## LLxprt Architecture Facts (Verified)

- **`runExitCleanup()`** exists at `packages/cli/src/utils/cleanup.ts:20` — runs registered cleanup functions
- **`packages/cli/src/commands/utils.ts`** does NOT exist yet — needs to be created
- **8 `process.exit(1)` calls** across extension commands: install (2), uninstall (2), validate (2), list (1), link (1)
- **1 `process.exit(1)` call** in MCP: add.ts (line 47)
- **`extensions.tsx`** uses yargs CommandModule builder pattern
- **Extension commands** are all yargs CommandModule exports with `handler` functions
- **MCP commands** follow same pattern in `packages/cli/src/commands/mcp/`

## Implementation Steps (TDD per RULES.md)

### Phase 1: Create exitCli utility

**1a. RED — Write test first:**

Create `packages/cli/src/commands/utils.test.ts`:

- Test: `exitCli()` calls `runExitCleanup()` before `process.exit()`
  - Mock `runExitCleanup` from `../utils/cleanup.js`
  - Mock `process.exit`
  - Call `exitCli()`
  - Assert: `runExitCleanup` called before `process.exit`

- Test: `exitCli()` uses exit code 0 by default
  - Assert: `process.exit(0)` called

- Test: `exitCli(1)` passes error exit code
  - Assert: `process.exit(1)` called

- Test: `exitCli()` still calls `process.exit` even if `runExitCleanup` throws
  - Mock `runExitCleanup` to reject
  - Assert: `process.exit` still called

Run tests — should fail.

**1b. GREEN — Create `packages/cli/src/commands/utils.ts`:**

```typescript
/**
 * @license
 * Copyright 2025 Vybestack LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { runExitCleanup } from '../utils/cleanup.js';

export async function exitCli(exitCode = 0) {
  try {
    await runExitCleanup();
  } finally {
    process.exit(exitCode);
  }
}
```

Note: `try/finally` ensures `process.exit` is called even if `runExitCleanup()` throws. While `runExitCleanup()` internally swallows errors per cleanup function, a mock in tests could force it to throw. The `finally` makes exitCli unconditionally terminate.

Run tests — should pass.

**1c. Verify:** `npm run lint && npm run typecheck`

### Phase 2: Add output middleware to extensions command builder

**2a. Update `packages/cli/src/commands/extensions.tsx`:**

After Batch 10 (d1e35f86) lands, `initializeOutputListenersAndFlush` will exist in `gemini.tsx` or a utils file. Add it as middleware to the extensions yargs builder:

```typescript
import { initializeOutputListenersAndFlush } from '../gemini.js';

// In builder:
.middleware(() => initializeOutputListenersAndFlush())
```

**HARD DEPENDENCY**: This step can ONLY be completed AFTER Batch 10 (d1e35f86) lands. `initializeOutputListenersAndFlush` does NOT exist in the current codebase (verified: no grep match in gemini.tsx). It is created by the stdout protection commit.

If Batch 10 has NOT been applied yet at execution time:
1. SKIP Phase 2 entirely (do NOT add the middleware import)
2. Add a TODO comment in extensions.tsx: `// TODO: Add initializeOutputListenersAndFlush middleware after stdout protection lands`
3. Continue with Phases 3-6 — exitCli is still valuable without the output middleware
4. After Batch 10 lands, come back and add the middleware

**2b. Similarly update `packages/cli/src/commands/mcp.ts`** if it has a yargs builder.

**2c. Verify:** `npm run lint && npm run typecheck`

### Phase 3: Replace process.exit with exitCli in extension commands

For each file, the change is: (a) add `import { exitCli } from '../utils.js'` and (b) replace `process.exit(N)` with `await exitCli(N)`.

**3a. RED — Update extension command tests:**

For each test file, add mock for `exitCli`:
```typescript
vi.mock('../utils.js', () => ({
  exitCli: vi.fn(),
}));
```

Update test assertions that check for `process.exit` to instead check for `exitCli`:
- `packages/cli/src/commands/extensions/install.test.ts`
- `packages/cli/src/commands/extensions/uninstall.test.ts`
- `packages/cli/src/commands/extensions/validate.test.ts`
- `packages/cli/src/commands/extensions/list.test.ts`
- `packages/cli/src/commands/extensions/link.test.ts`

Also add `await exitCli()` assertion at end of successful handler flows (upstream adds exitCli to ALL handlers, not just error paths):
- `packages/cli/src/commands/extensions/enable.test.ts`
- `packages/cli/src/commands/extensions/disable.test.ts`
- `packages/cli/src/commands/extensions/update.test.ts`
- `packages/cli/src/commands/extensions/new.test.ts`

Run tests — should fail (still calling process.exit, not exitCli).

**3b. GREEN — Update each extension command:**

| File | Changes |
|------|---------|
| `extensions/install.ts` | Replace 2× `process.exit(1)` → `await exitCli(1)`, add `await exitCli()` at end of handler |
| `extensions/uninstall.ts` | Replace 2× `process.exit(1)` → `await exitCli(1)`, add `await exitCli()` at end |
| `extensions/validate.ts` | Replace 2× `process.exit(1)` → `await exitCli(1)`, add `await exitCli()` at end |
| `extensions/list.ts` | Replace 1× `process.exit(1)` → `await exitCli(1)`, add `await exitCli()` at end |
| `extensions/link.ts` | Replace 1× `process.exit(1)` → `await exitCli(1)`, add `await exitCli()` at end |
| `extensions/enable.ts` | Add `await exitCli()` at end of handler (no current process.exit) |
| `extensions/disable.ts` | Add `await exitCli()` at end of handler |
| `extensions/update.ts` | Add `await exitCli()` at end of handler |
| `extensions/new.ts` | Add `await exitCli()` at end of handler |

All files: add `import { exitCli } from '../utils.js';`

Run tests — should pass.

**3c. Verify:** `npm run lint && npm run typecheck && npm run test`

### Phase 4: Replace process.exit with exitCli in MCP commands

**4a. RED — Update MCP command tests:**

- `packages/cli/src/commands/mcp/add.test.ts` — mock exitCli, update process.exit assertions
- `packages/cli/src/commands/mcp/list.test.ts` — add exitCli mock if needed
- `packages/cli/src/commands/mcp/remove.test.ts` — add exitCli mock if needed

**4b. GREEN — Update MCP commands:**

| File | Changes |
|------|---------|
| `mcp/add.ts` | Replace `process.exit(1)` → `await exitCli(1)`, add `await exitCli()` at end |
| `mcp/list.ts` | Add `await exitCli()` at end of handler |
| `mcp/remove.ts` | Add `await exitCli()` at end of handler |

All files: add `import { exitCli } from '../utils.js';`

**4c. Verify:** `npm run lint && npm run typecheck && npm run test`

### Phase 5: Remove early-exit block from config.ts (MANDATORY)

LLxprt's `packages/cli/src/config/config.ts` has an early-exit block at lines 596-610 that force-exits after MCP/extensions subcommands:

```typescript
// Lines 596-598: MCP early exit
if (result._ && result._.length > 0 && result._[0] === 'mcp') {
  process.exit(0);
}

// Lines 601-610: Extensions early exit  
if (result._ && result._.length > 0 && 
    (result._[0] === 'extensions' || result._[0] === 'extension' || result._[0] === 'ext')) {
  process.exit(0);
}
```

**This block MUST be removed.** With exitCli added to every handler (Phase 3-4), each command manages its own shutdown. Keeping this block creates a race: the config.ts block would call `process.exit(0)` before the handler's `exitCli()` runs cleanup, causing:
- Skipped output flushing
- Skipped cleanup functions
- Potential data loss

**5a. RED** — Add test: verify `parseArguments` does NOT call `process.exit` when command is 'extensions' or 'mcp' (update existing config.test.ts if such a test exists; if not, add one).

**5b. GREEN** — Remove lines 596-610 from `packages/cli/src/config/config.ts`.

**5c. Verify:** `npm run lint && npm run typecheck && npm run test`

### Phase 6: Full verification

```bash
npm run lint && npm run typecheck && npm run test && npm run format && npm run build
node scripts/start.js --profile-load synthetic --prompt "write me a haiku"
```

## File Inventory

### New files:
| File | Description |
|------|-------------|
| `packages/cli/src/commands/utils.ts` | `exitCli()` utility for clean CLI shutdown |
| `packages/cli/src/commands/utils.test.ts` | Tests for exitCli |

### Modified files:
| File | Change |
|------|--------|
| `packages/cli/src/commands/extensions.tsx` | Add `initializeOutputListenersAndFlush` middleware |
| `packages/cli/src/commands/extensions/install.ts` | Replace process.exit → exitCli |
| `packages/cli/src/commands/extensions/uninstall.ts` | Replace process.exit → exitCli |
| `packages/cli/src/commands/extensions/validate.ts` | Replace process.exit → exitCli |
| `packages/cli/src/commands/extensions/list.ts` | Replace process.exit → exitCli |
| `packages/cli/src/commands/extensions/link.ts` | Replace process.exit → exitCli |
| `packages/cli/src/commands/extensions/enable.ts` | Add exitCli at end |
| `packages/cli/src/commands/extensions/disable.ts` | Add exitCli at end |
| `packages/cli/src/commands/extensions/update.ts` | Add exitCli at end |
| `packages/cli/src/commands/extensions/new.ts` | Add exitCli at end |
| `packages/cli/src/commands/mcp/add.ts` | Replace process.exit → exitCli |
| `packages/cli/src/commands/mcp/list.ts` | Add exitCli at end |
| `packages/cli/src/commands/mcp/remove.ts` | Add exitCli at end |
| `packages/cli/src/commands/mcp.ts` | Add output middleware (if applicable) |
| `packages/cli/src/config/config.ts` | Remove early-exit block for mcp/extensions (lines 596-610) |
| 10+ test files | Update mocks and assertions for exitCli |

## Preservation Checklist

- [ ] `runExitCleanup()` in cleanup.ts stays unchanged — exitCli wraps it
- [ ] Vybestack copyright on new files
- [ ] `@vybestack/llxprt-code-core` imports throughout
- [ ] LLxprt-specific extension policy settings preserved (blockFromGit, reloading, etc.)
- [ ] MCP commands included in the lifecycle refactor (not just extensions)
- [ ] Handler logic unchanged — only exit/shutdown pattern modified
- [ ] Extension test mocking patterns updated to use exitCli instead of process.exit spy

## Scope Boundaries

This plan targets ONLY `process.exit` calls in:
- `packages/cli/src/commands/extensions/*.ts` (9 command files)
- `packages/cli/src/commands/mcp/*.ts` (3 command files)
- `packages/cli/src/config/config.ts` (early-exit block removal)

The following `process.exit` callsites are **intentionally OUT OF SCOPE** — they serve different lifecycle purposes and should NOT be migrated to `exitCli`:
- `packages/cli/src/nonInteractiveCli.ts` — non-interactive mode exit
- `packages/cli/src/validateNonInterActiveAuth.ts` — auth validation exit
- `packages/cli/src/utils/errors.ts` — fatal error handler
- `packages/cli/src/ui/hooks/useFolderTrust.ts` — trust rejection exit
- `packages/cli/src/gemini.tsx` — main app lifecycle (already uses `runExitCleanup()` directly)

## Risk Assessment

- **Low risk** — Mechanical changes: add import + replace process.exit → exitCli + add exitCli at end
- **Medium dependency risk** — Phase 2 (output middleware) depends on Batch 10. If skipped, exitCli still works, just without output flushing middleware.
- **Test update volume** — 10+ test files need mock updates, but changes are formulaic
