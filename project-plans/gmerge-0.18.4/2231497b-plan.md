# Reimplement Plan: 2231497b — Click-to-focus + ToolMessage Refactor

## Upstream Commit
- **SHA:** `2231497b1f62a08d`
- **Subject:** feat: add click-to-focus support for interactive shell
- **Files touched:** 17 files, +1071/−415

## Why REIMPLEMENT (not PICK)

LLxprt's ToolMessage.tsx (500 lines) is monolithic — it contains `ToolStatusIndicator`, `ToolInfo`, `TrailingIndicator`, and result rendering all inline. Upstream has already extracted these into `ToolShared.tsx` and `ToolResultDisplay.tsx`. LLxprt also has no `useMouseClick.ts` or `ShellToolMessage.tsx`. Cherry-picking would produce massive conflicts on nearly every file.

The user explicitly wants the cleaner component structure: "don't skip refactorings and leave monoliths."

## What Upstream Does (Behavioral Goal)

1. **Extract shared components** → `ToolShared.tsx`: `ToolStatusIndicator`, `ToolInfo`, `TrailingIndicator`, `STATUS_INDICATOR_WIDTH`, `TextEmphasis` type
2. **Extract result rendering** → `ToolResultDisplay.tsx`: the entire result display block (markdown, diff, ANSI, todo, MaxSizedBox logic)
3. **Create `useMouseClick` hook** → detects mouse clicks on Ink components for click-to-focus
4. **Add click-to-focus** on `InputPrompt` (click to focus text input) and shell tool messages (click to focus interactive shell)
5. **Create `ShellToolMessage`** → specialized tool message for shell commands with click-to-focus integration

## Extraction Targets from LLxprt's ToolMessage.tsx

### → `ToolShared.tsx`
- `ToolStatusIndicator` (lines 409-456) — status icon renderer
- `ToolInfo` (lines 458-493) — tool name + description display
- `TrailingIndicator` (line 495-500) — spinner for active tools
- `STATUS_INDICATOR_WIDTH` constant (currently hardcoded in ToolMessage, needs extraction)
- `TextEmphasis` type export

### → `ToolResultDisplay.tsx`
- The result rendering block from `ToolMessage` (approximately lines 200-350):
  - Markdown rendering path (`MarkdownDisplay`)
  - Plain text rendering path (with `MaxSizedBox`)
  - Diff rendering path (`DiffRenderer`)
  - Todo rendering path (empty, handled by TodoTray)
  - ANSI output path (`AnsiOutputText`)
  - Character truncation logic (`MAXIMUM_RESULT_DISPLAY_CHARACTERS`)
  - Height calculation for available terminal space

### LLxprt-Specific Code to PRESERVE
- `stripShellMarkers` import and usage (LLxprt-specific shell output cleaning)
- Todo formatting logic (llxprt may have different todo display from upstream)
- Multi-provider imports from `@vybestack/llxprt-code-core`
- ANSI output rendering path
- `useKeypress` hook usage in ToolMessage (for shell input)
- `ShellInputPrompt` integration

## Implementation Steps

### Phase 1: Test-first — Write behavioral test for ToolShared

1. Create `packages/cli/src/ui/components/messages/ToolShared.test.tsx`
2. Test: `ToolStatusIndicator` renders correct symbols for each `ToolCallStatus`
3. Test: `ToolInfo` renders name + description with correct emphasis
4. Test: `TrailingIndicator` renders spinner
5. Run tests — they should fail (components not yet extracted)

### Phase 2: Extract ToolShared.tsx

6. Create `packages/cli/src/ui/components/messages/ToolShared.tsx`
7. Move `ToolStatusIndicator`, `ToolInfo`, `TrailingIndicator` from ToolMessage.tsx
8. Export `STATUS_INDICATOR_WIDTH = 3` and `TextEmphasis` type
9. Fix imports: use `@vybestack/llxprt-code-core` for `SHELL_TOOL_NAME`, `theme` from semantic-colors
10. Run `npm run lint && npm run typecheck` — should pass
11. Run ToolShared tests — should pass

### Phase 3: Extract ToolResultDisplay.tsx

12. Create `packages/cli/src/ui/components/messages/ToolResultDisplay.tsx`
13. Move the result rendering block from ToolMessage.tsx
14. Export `ToolResultDisplayProps` interface with: `resultDisplay`, `availableTerminalHeight`, `terminalWidth`, `renderOutputAsMarkdown`
15. Include: `MAXIMUM_RESULT_DISPLAY_CHARACTERS`, height calculation, markdown/plain/diff/todo/ANSI branches
16. **Preserve** `stripShellMarkers` usage — pass through from ToolMessage if needed
17. **Preserve** LLxprt's `useAlternateBuffer` check (via `useUIState` or prop)
18. Update ToolMessage.tsx to import and use `<ToolResultDisplay>` and components from ToolShared
19. Run `npm run typecheck` — should pass
20. Run existing ToolMessage tests — should still pass

### Phase 4: Create useMouseClick hook

21. Read upstream: `git show 2231497b:packages/cli/src/ui/hooks/useMouseClick.ts`
22. Create `packages/cli/src/ui/hooks/useMouseClick.ts` — adapt to LLxprt imports
23. Create `packages/cli/src/ui/hooks/useMouseClick.test.ts`
24. Run tests — should pass

### Phase 5: Add click-to-focus to InputPrompt

25. Read upstream changes to `InputPrompt.tsx` from the commit
26. Read current LLxprt `InputPrompt.tsx`
27. Add `useMouseClick` hook to InputPrompt for click-to-focus behavior
28. Update `InputPrompt.test.tsx` with click-to-focus test
29. Run `npm run typecheck && npm run lint`

### Phase 6: Wire UIActionsContext and shell processor

30. Read upstream `UIActionsContext.tsx` changes — check if new actions needed
31. Read upstream `shellCommandProcessor.ts` changes
32. Apply relevant changes to LLxprt versions
33. Run typecheck

### Phase 7: Wire AppContainer + test-utils

34. Read upstream `AppContainer.tsx` changes (destructuring, prop passing)
35. Apply to LLxprt's AppContainer (note: LLxprt has `DefaultAppLayout.tsx` too)
36. Update `test-utils/render.tsx` if mocking changes needed
37. Run full test suite

## File Inventory

### New files to create:
| File | Source |
|------|--------|
| `packages/cli/src/ui/components/messages/ToolShared.tsx` | Extract from ToolMessage.tsx |
| `packages/cli/src/ui/components/messages/ToolShared.test.tsx` | New tests |
| `packages/cli/src/ui/components/messages/ToolResultDisplay.tsx` | Extract from ToolMessage.tsx |
| `packages/cli/src/ui/hooks/useMouseClick.ts` | Adapt from upstream |
| `packages/cli/src/ui/hooks/useMouseClick.test.ts` | New tests |

### Existing files to modify:
| File | Change |
|------|--------|
| `packages/cli/src/ui/components/messages/ToolMessage.tsx` | Remove extracted code, import from ToolShared/ToolResultDisplay |
| `packages/cli/src/ui/components/InputPrompt.tsx` | Add useMouseClick for click-to-focus |
| `packages/cli/src/ui/components/InputPrompt.test.tsx` | Test click-to-focus |
| `packages/cli/src/ui/contexts/UIActionsContext.tsx` | Possible new actions |
| `packages/cli/src/ui/hooks/shellCommandProcessor.ts` | Shell focus changes |
| `packages/cli/src/ui/AppContainer.tsx` | Wire mouse click, pass new props |
| `packages/cli/src/test-utils/render.tsx` | Updated mocking |

## Preservation Checklist

- [ ] `stripShellMarkers` import and usage preserved
- [ ] `@vybestack/llxprt-code-core` imports (never `@google/gemini-cli-core`)
- [ ] Vybestack copyright on all new files
- [ ] Todo formatting kept as-is (LLxprt-specific)
- [ ] ANSI output path preserved (`AnsiOutputText`)
- [ ] `useKeypress` hook in ToolMessage preserved
- [ ] `ShellInputPrompt` integration preserved
- [ ] `semantic-colors.js` theme usage (not upstream's direct color values)
- [ ] Existing ToolMessage tests still pass after extraction

## Verification Checkpoints

1. After Phase 2 (ToolShared extraction): `npm run lint && npm run typecheck` — pass, ToolShared tests pass
2. After Phase 3 (ToolResultDisplay extraction): `npm run typecheck` — pass, existing ToolMessage tests pass
3. After Phase 4 (useMouseClick): `npm run typecheck` — pass, useMouseClick tests pass
4. After Phase 7 (full wiring): Full verify — `npm run lint && npm run typecheck && npm run test`

## Risk Assessment

- **Medium-high risk** — Extraction refactoring of a 500-line component into 3 files. Each extraction step must be verified independently.
- **Main risk**: Breaking existing ToolMessage rendering during extraction. Mitigated by running existing tests after each phase.
- **Secondary risk**: `useMouseClick` interaction with LLxprt's terminal handling (kitty protocol, mouse detection). The hook itself is simple but the integration needs care.
