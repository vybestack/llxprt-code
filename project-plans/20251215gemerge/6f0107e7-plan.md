# Implementation Plan: 6f0107e7 - Robust URL Validation in web_fetch

## Summary of Upstream Changes

Upstream commit `6f0107e7` ("fix(core): implement robust URL validation in web_fetch tool (#10834)"):
- Replaces regex-based `extractUrls()` with proper URL parsing via `parsePrompt()`
- Validates URLs using `new URL()` constructor (WHATWG standard)
- Rejects malformed URLs and unsupported protocols (only http/https allowed)
- Returns normalized URLs (e.g., `https://example.com` â†’ `https://example.com/`)
- Provides detailed error messages for invalid URLs in validation

## Critical Upstream Behavior Analysis

Upstream's `parsePrompt()` uses naive whitespace splitting (`text.split(/\s+/)`), which means:
- `"https://example.com."` becomes token `"https://example.com."`
- WHATWG URL() accepts this and normalizes to `"https://example.com./"`
- Trailing punctuation (`.`, `,`, `;`, etc.) becomes part of the URL

**This is problematic** because in natural language prompts like "Check https://example.com." the period is sentence punctuation, not part of the URL.

However, upstream ACCEPTS this behavior in their tests (see line 59, 87 of upstream test file). This means upstream intentionally allows trailing punctuation to be part of URLs.

## LLxprt-Specific Context

**File:** `packages/core/src/tools/google-web-fetch.ts`

**Current Implementation:**
- Uses `extractUrls()` function (line 30-33) with regex: `/(https?:\/\/[^\s]+)/g`
- Called in three locations:
  1. Line 83: `executeFallback()` - extracts URL for direct fetch
  2. Line 157: `shouldConfirmExecute()` - extracts URLs for confirmation dialog
  3. Line 187: `execute()` - extracts URL for main processing
- `validateToolParamValues()` method exists (line 415-427)
  - Current validation: simple string checks for `http://` or `https://`
  - Returns `string | null` (error message or null if valid)

**Test File:** `packages/core/src/tools/google-web-fetch.test.ts`
- Exists with existing tests for validation and execution
- **CRITICAL**: Line 90 expects `urls: ['https://example.com']` (no trailing slash)
- Uses vitest framework

**Logging System:**
- LLxprt uses `DebugLogger` from `../debug/DebugLogger.js`
- Pattern: `const logger = new DebugLogger('llxprt:tools:web-fetch');`
- Then use `logger.log()`, `logger.error()`, etc.
- **DO NOT use `console.debug()` or `console.error()`**

## LLxprt Decision: Improve on Upstream

We will **improve** upon upstream by stripping common trailing punctuation before URL validation. This provides better UX for natural language prompts while maintaining upstream's robustness.

## Implementation Steps

### Step 1: Replace extractUrls with parsePrompt Function

**File:** `packages/core/src/tools/google-web-fetch.ts`

Replace the `extractUrls` function (lines 29-33) with:

```typescript
/**
 * Parses a prompt to extract valid URLs and identify malformed ones.
 * Strips common trailing punctuation from tokens before URL validation.
 */
export function parsePrompt(text: string): {
  validUrls: string[];
  errors: string[];
} {
  const tokens = text.split(/\s+/);
  const validUrls: string[] = [];
  const errors: string[] = [];

  for (const token of tokens) {
    if (!token) continue;

    // Heuristic to check if the token appears to contain URL-like chars.
    if (token.includes('://')) {
      // Strip common trailing punctuation (period, comma, semicolon, colon, etc.)
      // This handles natural language like "Check https://example.com."
      const cleaned = token.replace(/[.,;:!?]+$/, '');

      try {
        // Validate with new URL()
        const url = new URL(cleaned);

        // Allowlist protocols
        if (['http:', 'https:'].includes(url.protocol)) {
          validUrls.push(url.href);
        } else {
          errors.push(
            `Unsupported protocol in URL: "${cleaned}". Only http and https are supported.`,
          );
        }
      } catch (_) {
        // new URL() threw, so it's malformed according to WHATWG standard
        errors.push(`Malformed URL detected: "${cleaned}".`);
      }
    }
  }

  return { validUrls, errors };
}
```

### Step 2: Update All extractUrls Usages

**Location 1: Line 83 in executeFallback()**
```typescript
// BEFORE:
const urls = extractUrls(this.params.prompt);

// AFTER:
const { validUrls: urls } = parsePrompt(this.params.prompt);
```

**Location 2: Lines 157-169 in shouldConfirmExecute()**
```typescript
// BEFORE:
const urls = extractUrls(this.params.prompt).map((url) => {
  try {
    const urlObj = new URL(url);
    if (urlObj.hostname === 'github.com' && url.includes('/blob/')) {
      return url
        .replace('github.com', 'raw.githubusercontent.com')
        .replace('/blob/', '/');
    }
  } catch (_) {
    // Ignore invalid URLs
  }
  return url;
});

// AFTER:
const { validUrls } = parsePrompt(this.params.prompt);
const urls = validUrls.map((url) => {
  if (url.includes('github.com') && url.includes('/blob/')) {
    return url
      .replace('github.com', 'raw.githubusercontent.com')
      .replace('/blob/', '/');
  }
  return url;
});
```

**Location 3: Line 187 in execute()**
```typescript
// BEFORE:
const urls = extractUrls(userPrompt);

// AFTER:
const { validUrls: urls } = parsePrompt(userPrompt);
```

### Step 3: Update validateToolParamValues Method

**File:** `packages/core/src/tools/google-web-fetch.ts` (lines 415-427)

```typescript
// BEFORE:
protected override validateToolParamValues(
  params: GoogleWebFetchToolParams,
): string | null {
  if (!params.prompt || params.prompt.trim() === '') {
    return "The 'prompt' parameter cannot be empty and must contain URL(s) and instructions.";
  }
  if (
    !params.prompt.includes('http://') &&
    !params.prompt.includes('https://')
  ) {
    return "The 'prompt' must contain at least one valid URL (starting with http:// or https://).";
  }
  return null;
}

// AFTER:
protected override validateToolParamValues(
  params: GoogleWebFetchToolParams,
): string | null {
  if (!params.prompt || params.prompt.trim() === '') {
    return "The 'prompt' parameter cannot be empty and must contain URL(s) and instructions.";
  }

  const { validUrls, errors } = parsePrompt(params.prompt);

  if (errors.length > 0) {
    return `Error(s) in prompt URLs:\n- ${errors.join('\n- ')}`;
  }

  if (validUrls.length === 0) {
    return "The 'prompt' must contain at least one valid URL (starting with http:// or https://).";
  }

  return null;
}
```

### Step 4: Replace console.debug with DebugLogger

**File:** `packages/core/src/tools/google-web-fetch.ts`

Add import at top of file (after existing imports):
```typescript
import { DebugLogger } from '../debug/DebugLogger.js';
```

Add logger constant after imports (before interfaces):
```typescript
const logger = new DebugLogger('llxprt:tools:web-fetch');
```

Replace console.debug calls:

**Line 253-259:**
```typescript
// BEFORE:
console.debug(
  `[WebFetchTool] Full response for prompt "${userPrompt.substring(
    0,
    50,
  )}...":`,
  JSON.stringify(response, null, 2),
);

// AFTER:
logger.log(
  `Full response for prompt "${userPrompt.substring(0, 50)}...":`,
  JSON.stringify(response, null, 2),
);
```

**Line 352-355:**
```typescript
// BEFORE:
console.debug(
  `[WebFetchTool] Formatted tool response for prompt "${userPrompt}:\n\n":`,
  llmContent,
);

// AFTER:
logger.log(
  `Formatted tool response for prompt "${userPrompt}:\n\n":`,
  llmContent,
);
```

### Step 5: Add Tests

**File:** `packages/core/src/tools/google-web-fetch.test.ts`

Add import for parsePrompt (update line 8):
```typescript
import { GoogleWebFetchTool, parsePrompt } from './google-web-fetch.js';
```

Add new test suite after imports and before the main `GoogleWebFetchTool` describe block:

```typescript
describe('parsePrompt', () => {
  it('should extract valid URLs separated by whitespace', () => {
    const prompt = 'Go to https://example.com and http://google.com';
    const { validUrls, errors } = parsePrompt(prompt);

    expect(errors).toHaveLength(0);
    expect(validUrls).toHaveLength(2);
    expect(validUrls[0]).toBe('https://example.com/');
    expect(validUrls[1]).toBe('http://google.com/');
  });

  it('should strip trailing punctuation from URLs', () => {
    const prompt = 'Check https://example.com. and https://google.com,';
    const { validUrls, errors } = parsePrompt(prompt);

    expect(errors).toHaveLength(0);
    expect(validUrls).toHaveLength(2);
    // After stripping punctuation, WHATWG URL normalizes to include trailing slash
    expect(validUrls[0]).toBe('https://example.com/');
    expect(validUrls[1]).toBe('https://google.com/');
  });

  it('should detect URLs wrapped in punctuation as malformed', () => {
    const prompt = 'Read (https://example.com)';
    const { validUrls, errors } = parsePrompt(prompt);

    expect(validUrls).toHaveLength(0);
    expect(errors).toHaveLength(1);
    expect(errors[0]).toContain('Malformed URL detected');
    expect(errors[0]).toContain('(https://example.com');
  });

  it('should detect unsupported protocols (httpshttps://)', () => {
    const prompt =
      'Summarize httpshttps://github.com/JuliaLang/julia/issues/58346';
    const { validUrls, errors } = parsePrompt(prompt);

    expect(validUrls).toHaveLength(0);
    expect(errors).toHaveLength(1);
    expect(errors[0]).toContain('Unsupported protocol');
    expect(errors[0]).toContain(
      'httpshttps://github.com/JuliaLang/julia/issues/58346',
    );
  });

  it('should detect unsupported protocols (ftp://)', () => {
    const prompt = 'ftp://example.com/file.txt';
    const { validUrls, errors } = parsePrompt(prompt);

    expect(validUrls).toHaveLength(0);
    expect(errors).toHaveLength(1);
    expect(errors[0]).toContain('Unsupported protocol');
  });

  it('should detect malformed URLs', () => {
    // http:// is not a valid URL in Node's new URL()
    const prompt = 'http://';
    const { validUrls, errors } = parsePrompt(prompt);

    expect(validUrls).toHaveLength(0);
    expect(errors).toHaveLength(1);
    expect(errors[0]).toContain('Malformed URL detected');
  });

  it('should handle prompts with no URLs', () => {
    const prompt = 'hello world';
    const { validUrls, errors } = parsePrompt(prompt);

    expect(validUrls).toHaveLength(0);
    expect(errors).toHaveLength(0);
  });

  it('should handle mixed valid and invalid URLs', () => {
    const prompt = 'Valid: https://google.com, Invalid: ftp://bad.com';
    const { validUrls, errors } = parsePrompt(prompt);

    expect(validUrls).toHaveLength(1);
    // Comma is stripped before URL parsing
    expect(validUrls[0]).toBe('https://google.com/');
    expect(errors).toHaveLength(1);
    expect(errors[0]).toContain('ftp://bad.com');
  });
});
```

Update existing validation tests in the `GoogleWebFetchTool` describe block:

```typescript
describe('validateToolParamValues', () => {
  it('should throw if prompt is empty', () => {
    const tool = new GoogleWebFetchTool(mockConfig);
    expect(() => tool.build({ prompt: '' })).toThrow(
      "The 'prompt' parameter cannot be empty",
    );
  });

  it('should throw if prompt contains no URLs', () => {
    const tool = new GoogleWebFetchTool(mockConfig);
    expect(() => tool.build({ prompt: 'hello world' })).toThrow(
      "The 'prompt' must contain at least one valid URL",
    );
  });

  it('should throw if prompt contains malformed URLs (httpshttps://)', () => {
    const tool = new GoogleWebFetchTool(mockConfig);
    const prompt = 'fetch httpshttps://example.com';
    expect(() => tool.build({ prompt })).toThrow('Error(s) in prompt URLs:');
  });

  it('should pass if prompt contains at least one valid URL', () => {
    const tool = new GoogleWebFetchTool(mockConfig);
    expect(() =>
      tool.build({ prompt: 'fetch https://example.com' }),
    ).not.toThrow();
  });
});
```

Update existing `shouldConfirmExecute` test to expect normalized URLs:

```typescript
it('should return confirmation details with the correct prompt and parsed urls', async () => {
  const tool = new GoogleWebFetchTool(mockConfig);
  const params = { prompt: 'fetch https://example.com' };
  const invocation = tool.build(params);
  const confirmationDetails = await invocation.shouldConfirmExecute(
    new AbortController().signal,
  );

  expect(confirmationDetails).toEqual({
    type: 'info',
    title: 'Confirm Web Fetch',
    prompt: 'fetch https://example.com',
    urls: ['https://example.com/'], // Note the trailing slash from URL normalization
    onConfirm: expect.any(Function),
  });
});
```

## Files to Modify

| File | Changes |
|------|---------|
| `packages/core/src/tools/google-web-fetch.ts` | Replace `extractUrls()` with `parsePrompt()` (with punctuation stripping), update 3 call sites, enhance `validateToolParamValues()`, replace console.debug with DebugLogger |
| `packages/core/src/tools/google-web-fetch.test.ts` | Add `parsePrompt()` tests, update validation tests, update URL expectations for trailing slash |

## Acceptance Criteria

- [ ] `parsePrompt()` function properly validates URLs using `new URL()` constructor
- [ ] Trailing punctuation (`.`, `,`, `;`, `:`, `!`, `?`) is stripped from URLs before validation
- [ ] Malformed URLs (e.g., `http://`, `(https://example.com)`) are rejected with clear error messages
- [ ] Unsupported protocols (e.g., `ftp://`, `httpshttps://`) are rejected
- [ ] Valid http/https URLs are accepted and normalized (trailing slash added by WHATWG URL)
- [ ] All three call sites of `extractUrls()` replaced with `parsePrompt()`
- [ ] GitHub URL conversion still works correctly (unchanged logic, just using new parser)
- [ ] `validateToolParamValues()` provides detailed error messages for invalid URLs
- [ ] All console.debug calls replaced with DebugLogger
- [ ] All new tests pass
- [ ] Existing test at line 90 updated to expect trailing slash in normalized URL
- [ ] No regression in existing functionality

## Testing Strategy

1. Run unit tests: `npm test -- google-web-fetch.test.ts`
2. Test malformed URL rejection: `llxprt --provider gemini "fetch httpshttps://example.com"`
3. Test unsupported protocol: `llxprt --provider gemini "fetch ftp://example.com/file"`
4. Test valid URL: `llxprt --provider gemini "fetch https://example.com"`
5. Test trailing punctuation handling: `llxprt --provider gemini "fetch https://example.com."`
6. Test mixed valid/invalid: Ensure only valid URLs are processed
7. Verify GitHub URL conversion still works with test or manual check

## Notes

- LLxprt's `google-web-fetch.ts` is a fork of upstream's `web-fetch.ts` with multi-provider support
- The core URL validation logic is identical between upstream and LLxprt
- **LLxprt improvement**: We strip trailing punctuation before URL validation, which upstream does not do
- This change improves security and user experience with better error messages
- URL normalization (e.g., adding trailing slash) is a side effect of `new URL().href` but doesn't affect functionality
- The trailing slash in normalized URLs is expected WHATWG behavior and tests must account for it
