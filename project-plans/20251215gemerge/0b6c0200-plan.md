# Implementation Plan: 0b6c0200 - Failed Response Retry via Extra Prompt

## Summary of Upstream Changes

Upstream commit `0b6c0200` ("feat(core): Failed Response Retry via Extra Prompt (#10828)"):
- Adds `continueOnFailedApiCall` config flag to allow automatic retry on stream failures
- Detects `InvalidStream` events from the model API and automatically retries once
- Injects "Please continue" prompt on retry to encourage model to complete the response
- Updates UI to gracefully handle InvalidStream without crashing

## Current State in LLxprt

**Already Implemented:**
- `GeminiEventType.InvalidStream` exists in `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/turn.ts` (line 72)
- `ServerGeminiInvalidStreamEvent` type defined in `turn.ts` (lines 79-81)
- `InvalidStreamError` class exists in `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/geminiChat.ts` (lines 374-388)
- Turn.run() already yields InvalidStream events when it catches InvalidStreamError (line 393-394 in turn.ts)

**Missing:**
- Config flag `continueOnFailedApiCall` not yet added to EphemeralSettings
- Retry logic in GeminiClient.sendMessageStream() not implemented
- No tests for InvalidStream retry behavior

## LLxprt Configuration Architecture

**Config File Location:**
- User settings: `~/.llxprt/settings.json`
- This is where runtime configuration is stored

**Code Locations:**
- Type definitions: `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/types/modelParams.ts`
- Config class: `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/config/config.ts`
- Settings service: `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/settings/SettingsService.ts`

## Implementation Steps

### Step 1: Add Config Flag to EphemeralSettings

**File:** `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/types/modelParams.ts`

**Location:** Add to `EphemeralSettings` interface (after line 119, before the load balancer comment on line 121)

```typescript
  /** Enable tool-specific prompts from ~/.llxprt/prompts/tools/** (default: false) */
  'enable-tool-prompts'?: boolean;
  /** Continue on failed API call by retrying with "Please continue" prompt (default: true) */
  'continue-on-failed-api-call'?: boolean;

  // Load balancer advanced failover settings (Phase 3, Issue #489)
```

**Rationale:**
- Uses LLxprt naming convention with kebab-case
- Defaults to `true` (auto-retry enabled by default, matching upstream intent)
- Placed logically with other behavior flags before the load balancer settings section

### Step 2: Add Getter Method to Config Class

**File:** `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/config/config.ts`

**Location:** Add method to Config class (search for similar getter methods like `getMaxSessionTurns()`)

```typescript
getContinueOnFailedApiCall(): boolean {
  return this.settingsService.getCurrentSettings()['continue-on-failed-api-call'] ?? true;
}
```

### Step 3: Implement Retry Logic in GeminiClient

**File:** `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/client.ts`

**Location:** In `sendMessageStream()` method, around line 1306-1358 where the event loop processes Turn.run() output

**Current Code Structure (lines 1303-1358):**
```typescript
const resultStream = turn.run(request, signal);

// Stream events, deferring Content/Finished/Citation until we decide on a retry
for await (const event of resultStream) {
  // ... event processing ...

  if (event.type === GeminiEventType.Error) {
    for (const deferred of deferredEvents) {
      yield deferred;
    }
    return turn;
  }
}
```

**New Implementation:**
Add InvalidStream detection and tracking at the start of the while loop (before line 1224):

```typescript
async *sendMessageStream(
  initialRequest: PartListUnion,
  signal: AbortSignal,
  prompt_id: string,
  turns: number = this.MAX_TURNS,
): AsyncGenerator<ServerGeminiStreamEvent, Turn> {
  // ... existing setup code ...

  let baseRequest: PartListUnion = Array.isArray(initialRequest)
    ? [...(initialRequest as Part[])]
    : initialRequest;
  let retryCount = 0;
  const MAX_RETRIES = 2;
  let lastTurn: Turn | undefined;
  let hadToolCallsThisTurn = false;
  let invalidStreamCount = 0; // NEW: Track InvalidStream occurrences
  const MAX_INVALID_STREAM_RETRIES = 1; // NEW: Retry InvalidStream at most once

  while (retryCount < MAX_RETRIES) {
    // ... existing retry loop code ...
```

Then modify the event processing loop (around line 1306-1358):

```typescript
for await (const event of resultStream) {
  // ... existing event processing ...

  // NEW: Detect InvalidStream
  if (event.type === GeminiEventType.InvalidStream) {
    const continueOnFailedApiCall = this.config.getContinueOnFailedApiCall();

    if (continueOnFailedApiCall && invalidStreamCount < MAX_INVALID_STREAM_RETRIES) {
      invalidStreamCount++;

      // Log the retry attempt
      logger.debug(
        () => `InvalidStream detected, retrying (attempt ${invalidStreamCount}/${MAX_INVALID_STREAM_RETRIES})`
      );

      // Yield the InvalidStream event to UI
      yield event;

      // Inject continuation prompt and retry
      const continuationMessage: Part[] = [
        { text: 'System: Please continue.' }
      ];

      // Create new turn with continuation message
      const continuationTurn = new Turn(
        this.getChat(),
        prompt_id,
        DEFAULT_AGENT_ID,
        providerName,
      );

      // Run the continuation
      const continuationStream = continuationTurn.run(continuationMessage, signal);

      // Process continuation stream
      for await (const continuationEvent of continuationStream) {
        if (this.loopDetector.addAndCheck(continuationEvent)) {
          yield { type: GeminiEventType.LoopDetected };
          return continuationTurn;
        }
        yield continuationEvent;

        if (continuationEvent.type === GeminiEventType.Error) {
          return continuationTurn;
        }
      }

      return continuationTurn;
    } else {
      // Max retries reached or disabled - yield event and return
      logger.debug(
        () => `InvalidStream: max retries reached or disabled (count: ${invalidStreamCount})`
      );
      yield event;
      for (const deferred of deferredEvents) {
        yield deferred;
      }
      return turn;
    }
  }

  if (event.type === GeminiEventType.Error) {
    for (const deferred of deferredEvents) {
      yield deferred;
    }
    return turn;
  }
}
```

**Key Implementation Details:**
- Track `invalidStreamCount` separately from general `retryCount` (todo retries)
- Limit to exactly 1 retry per InvalidStream (matches upstream behavior)
- Use config flag `getContinueOnFailedApiCall()` with default `true`
- Inject system message: `"System: Please continue."`
- Create new Turn instance for continuation to maintain prompt_id tracking
- Yield the InvalidStream event before retrying (so UI can show what happened)
- NO TELEMETRY - no ClearcutLogger or Google analytics calls

### Step 4: Add Unit Tests

**File:** `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/client.test.ts`

**Add test case:**
```typescript
describe('InvalidStream retry behavior', () => {
  it('should retry once on InvalidStream when continueOnFailedApiCall is true', async () => {
    // Setup: Mock GeminiChat to emit InvalidStream on first call, then succeed
    const mockChat = {
      run: vi.fn()
        .mockImplementationOnce(async function* () {
          yield { type: GeminiEventType.InvalidStream };
        })
        .mockImplementationOnce(async function* () {
          yield { type: GeminiEventType.Content, value: { text: 'Continued response' } };
          yield { type: GeminiEventType.Finished };
        }),
      getHistory: vi.fn().mockReturnValue([]),
      setHistory: vi.fn(),
    };

    // Setup config with continueOnFailedApiCall: true
    const config = createTestConfig({ 'continue-on-failed-api-call': true });
    const client = new GeminiClient(config);
    client['chat'] = mockChat; // Inject mock

    // Execute
    const events = [];
    for await (const event of client.sendMessageStream([{ text: 'test' }], new AbortController().signal, 'test-prompt-id')) {
      events.push(event);
    }

    // Assert
    expect(events).toContainEqual({ type: GeminiEventType.InvalidStream });
    expect(events).toContainEqual(expect.objectContaining({
      type: GeminiEventType.Content,
      value: expect.objectContaining({ text: 'Continued response' })
    }));
    expect(mockChat.run).toHaveBeenCalledTimes(2);
  });

  it('should not retry when continueOnFailedApiCall is false', async () => {
    // Setup: Mock to emit InvalidStream
    const mockChat = {
      run: vi.fn().mockImplementation(async function* () {
        yield { type: GeminiEventType.InvalidStream };
      }),
      getHistory: vi.fn().mockReturnValue([]),
      setHistory: vi.fn(),
    };

    const config = createTestConfig({ 'continue-on-failed-api-call': false });
    const client = new GeminiClient(config);
    client['chat'] = mockChat;

    // Execute
    const events = [];
    for await (const event of client.sendMessageStream([{ text: 'test' }], new AbortController().signal, 'test-prompt-id')) {
      events.push(event);
    }

    // Assert: Should emit InvalidStream and stop, no retry
    expect(events).toContainEqual({ type: GeminiEventType.InvalidStream });
    expect(mockChat.run).toHaveBeenCalledTimes(1);
  });

  it('should retry at most once per InvalidStream', async () => {
    // Setup: Mock to emit InvalidStream twice in a row
    const mockChat = {
      run: vi.fn()
        .mockImplementation(async function* () {
          yield { type: GeminiEventType.InvalidStream };
        }),
      getHistory: vi.fn().mockReturnValue([]),
      setHistory: vi.fn(),
    };

    const config = createTestConfig({ 'continue-on-failed-api-call': true });
    const client = new GeminiClient(config);
    client['chat'] = mockChat;

    // Execute
    const events = [];
    for await (const event of client.sendMessageStream([{ text: 'test' }], new AbortController().signal, 'test-prompt-id')) {
      events.push(event);
    }

    // Assert: Should call run twice (original + 1 retry), then stop
    expect(mockChat.run).toHaveBeenCalledTimes(2);
    const invalidStreamEvents = events.filter(e => e.type === GeminiEventType.InvalidStream);
    expect(invalidStreamEvents.length).toBe(2);
  });
});
```

### Step 5: Handle in UI (CLI)

**File:** `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/cli/src/ui/hooks/useGeminiStream.ts`

**Location:** In the event handler switch statement

**Add case:**
```typescript
case GeminiEventType.InvalidStream:
  // Log but don't crash - retry is handled in client
  logger.debug('Stream returned invalid response, client will retry');
  break;
```

**Rationale:** The UI should simply acknowledge the event without crashing. The actual retry logic is in the client layer.

## Files to Modify

| File | Change | Lines |
|------|--------|-------|
| `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/types/modelParams.ts` | Add `continue-on-failed-api-call` to EphemeralSettings | ~120 |
| `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/config/config.ts` | Add getter `getContinueOnFailedApiCall()` | Config class |
| `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/client.ts` | Add InvalidStream retry logic in sendMessageStream() | 1300-1358 |
| `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/client.test.ts` | Add unit tests for retry behavior | New tests |
| `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/cli/src/ui/hooks/useGeminiStream.ts` | Handle InvalidStream event | Event switch |

## Critical: DO NOT ADD TELEMETRY

**IMPORTANT:** Do NOT port any ClearcutLogger, telemetry, or Google analytics code from upstream. LLxprt does not send telemetry to Google.

## Integration Points

**Where InvalidStreamError originates:**
- `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/geminiChat.ts` lines 2253-2258
- Thrown when response has no finish reason or no text content
- Three error types: `NO_FINISH_REASON`, `NO_RESPONSE_TEXT`, `NO_FINISH_REASON_NO_TEXT`

**Where it's caught and converted to event:**
- `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/turn.ts` lines 393-394
- Turn.run() catches InvalidStreamError and yields `{ type: GeminiEventType.InvalidStream }`

**Where retry will be implemented:**
- `/Users/acoliver/projects/llxprt-code-branches/llxprt-code-1/packages/core/src/core/client.ts` line ~1306+
- In the event processing loop within sendMessageStream()
- After Turn.run() completes and yields InvalidStream event

## Acceptance Criteria

- [ ] InvalidStream does not terminate session abruptly
- [ ] Retries once with "System: Please continue." message
- [ ] After one retry, yields terminal state (no infinite loop)
- [ ] Config flag `continue-on-failed-api-call` controls behavior (default: true)
- [ ] No telemetry-to-Google added
- [ ] Unit tests verify retry behavior
- [ ] UI gracefully handles InvalidStream events without crashing
- [ ] Works correctly when flag is disabled (no retry, just return)

## Testing Strategy

1. **Unit tests:** Mock Turn.run() to emit InvalidStream, verify retry logic
2. **Integration test:** Simulate real InvalidStreamError from geminiChat
3. **Config test:** Verify flag defaults to true and can be disabled
4. **UI test:** Ensure CLI doesn't crash on InvalidStream event

## Notes

- This feature improves resilience when the model API returns incomplete responses
- The retry is a best-effort attempt; if it fails again, the session terminates gracefully
- The implementation is purely defensive - no changes to how InvalidStreamError is thrown
- Uses existing LLxprt architecture (EphemeralSettings, SettingsService, Config pattern)
