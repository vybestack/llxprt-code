# Implementation Plan: 4f5b3357 - Cyclic Schema MCP Integration Test

## Summary of Upstream Changes

Upstream commit `4f5b3357` ("fix(tests): enable cyclic schema MCP tool test (#10912)"):
- Adds `mcp_server_cyclic_schema.test.ts`
- Tests MCP server with cyclic JSON schema
- Validates that LLxprt can handle MCP tools with recursive input schemas using JSON `$ref` keyword
- Ensures both the GenAI SDK and API calls succeed with cyclic schemas

**BLOCKED BY:** 5dc7059b (InteractiveRun class)

This plan depends on the `InteractiveRun` class being implemented first. The test uses `await rig.runInteractive()` which returns an `InteractiveRun` instance.

## API ALIGNMENT WITH 5dc7059b (CRITICAL)

**Verified InteractiveRun API from 5dc7059b plan (lines 97-155):**

| Method | Signature | Purpose |
|--------|-----------|---------|
| `expectText()` | `async expectText(text: string, timeout?: number)` | Wait for text with assertion (strips ANSI, case-insensitive) |
| `type()` | `async type(text: string)` | Type text with 5ms delay per character |
| `kill()` | `async kill()` | Kill the PTY process |
| `expectExit()` | `expectExit(): Promise<number>` | Wait for process exit with 60s timeout |

**IMPORTANT:** There is NO `sendKeys()` method in 5dc7059b. Use `type()` for ALL input including control characters like '\r' for Enter.

**Test Code Pattern:**
```typescript
const run = await rig.runInteractive();
await run.type('/mcp list');
await run.type('\r'); // Submit with Enter - uses type(), NOT sendKeys()
await run.expectText('tool_with_cyclic_schema');
```

**Why This Test Matters:**
Prior to a specific GenAI SDK commit, the Gemini API would reject tools with cyclic schemas because schemas were passed as strict typed objects rather than JSON strings. This test ensures we don't regress on handling complex tool schemas.

## Implementation Steps

### Step 1: Verify Dependencies

**Prerequisites:**
- Plan 5dc7059b must be completed (InteractiveRun class)
- `InteractiveRun` must have these methods (per 5dc7059b plan lines 97-155):
  - `type(text: string)` - Type text into PTY with 5ms delay per character
  - `expectText(text: string, timeout?: number)` - Wait for text with assertion (uses stripAnsi and case-insensitive matching)
  - `kill()` - Kill the PTY process
  - `expectExit()` - Wait for process exit

**API Verification:** The 5dc7059b plan (lines 112-131) confirms `expectText()` and `type()` are the correct method names. There is no `sendKeys()` method - use `type()` for all input including control characters.

### Step 2: Create Test File

**File:** `integration-tests/mcp_server_cyclic_schema.test.ts` (NEW)

```typescript
/**
 * @license
 * Copyright 2024 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/**
 * This test verifies we can provide MCP tools with recursive input schemas
 * (in JSON, using the $ref keyword) and both the GenAI SDK and the provider
 * API calls succeed. This ensures LLxprt can handle MCP tools with cyclic
 * schema definitions without rejecting them.
 *
 * If this test fails, it's likely because either the GenAI SDK or provider API
 * has become more restrictive about the type of tool parameter schemas that
 * are accepted.
 */

import { writeFileSync } from 'node:fs';
import { join } from 'node:path';
import { beforeAll, describe, it } from 'vitest';
import { TestRig } from './test-helper.js';

// Create a minimal MCP server that doesn't require external dependencies
// This implements the MCP protocol directly using Node.js built-ins
const serverScript = \`#!/usr/bin/env node
/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

const readline = require('readline');
const fs = require('fs');

// Debug logging to stderr (only when MCP_DEBUG or VERBOSE is set)
const debugEnabled = process.env['MCP_DEBUG'] === 'true' || process.env['VERBOSE'] === 'true';
function debug(msg) {
  if (debugEnabled) {
    fs.writeSync(2, \\\`[MCP-DEBUG] \\\${msg}\\\\n\\\`);
  }
}

debug('MCP server starting...');

// Simple JSON-RPC implementation for MCP
class SimpleJSONRPC {
  constructor() {
    this.handlers = new Map();
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      terminal: false
    });

    this.rl.on('line', (line) => {
      debug(\\\`Received line: \\\${line}\\\`);
      try {
        const message = JSON.parse(line);
        debug(\\\`Parsed message: \\\${JSON.stringify(message)}\\\`);
        this.handleMessage(message);
      } catch (e) {
        debug(\\\`Parse error: \\\${e.message}\\\`);
      }
    });
  }

  send(message) {
    const msgStr = JSON.stringify(message);
    debug(\\\`Sending message: \\\${msgStr}\\\`);
    process.stdout.write(msgStr + '\\\\n');
  }

  async handleMessage(message) {
    if (message.method && this.handlers.has(message.method)) {
      try {
        const result = await this.handlers.get(message.method)(message.params || {});
        if (message.id !== undefined) {
          this.send({
            jsonrpc: '2.0',
            id: message.id,
            result
          });
        }
      } catch (error) {
        if (message.id !== undefined) {
          this.send({
            jsonrpc: '2.0',
            id: message.id,
            error: {
              code: -32603,
              message: error.message
            }
          });
        }
      }
    } else if (message.id !== undefined) {
      this.send({
        jsonrpc: '2.0',
        id: message.id,
        error: {
          code: -32601,
          message: 'Method not found'
        }
      });
    }
  }

  on(method, handler) {
    this.handlers.set(method, handler);
  }
}

// Create MCP server
const rpc = new SimpleJSONRPC();

// Handle initialize
rpc.on('initialize', async (params) => {
  debug('Handling initialize request');
  return {
    protocolVersion: '2024-11-05',
    capabilities: {
      tools: {}
    },
    serverInfo: {
      name: 'cyclic-schema-server',
      version: '1.0.0'
    }
  };
});

// Handle tools/list
rpc.on('tools/list', async () => {
  debug('Handling tools/list request');
  return {
    tools: [{
      name: 'tool_with_cyclic_schema',
      inputSchema: {
        type: 'object',
        properties: {
          data: {
            type: 'array',
            items: {
              type: 'object',
              properties: {
                child: { $ref: '#/properties/data/items' },
              },
            },
          },
        },
      }
    }]
  };
});

// Send initialization notification
rpc.send({
  jsonrpc: '2.0',
  method: 'initialized'
});
\`;

describe('mcp server with cyclic tool schema is detected', () => {
  const rig = new TestRig();

  beforeAll(async () => {
    // Setup test directory with MCP server configuration
    await rig.setup('cyclic-schema-mcp-server', {
      settings: {
        mcpServers: {
          'cyclic-schema-server': {
            command: 'node',
            args: ['mcp-server.cjs'],
          },
        },
      },
    });

    // Create server script in the test directory
    const testServerPath = join(rig.testDir!, 'mcp-server.cjs');
    writeFileSync(testServerPath, serverScript);

    // Make the script executable (though running with 'node' should work anyway)
    if (process.platform !== 'win32') {
      const { chmodSync } = await import('node:fs');
      chmodSync(testServerPath, 0o755);
    }
  });

  it('mcp tool list should include tool with cyclic tool schema', async () => {
    const run = await rig.runInteractive();

    await run.type('/mcp list');
    await run.type('\r'); // Submit command with Enter key

    await run.expectText('tool_with_cyclic_schema');
  });
});
```

### Step 3: Verify LLxprt-Specific Adaptations

**Config Directory:**
- Uses `.llxprt` directory (TestRig.setup() already handles this correctly)
- Not `.gemini` as in upstream

**Settings Structure:**
- TestRig already configures settings correctly for LLxprt
- MCP server config goes in `settings.mcpServers` (same as upstream)

**Interactive Commands:**
- `/mcp list` command should work the same in LLxprt
- Test validates tool name appears in output

### Step 4: Understanding the Cyclic Schema

**The Schema Structure:**
```json
{
  "type": "object",
  "properties": {
    "data": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "child": { "$ref": "#/properties/data/items" }
        }
      }
    }
  }
}
```

**Why It's Cyclic:**
- The `child` property references `#/properties/data/items`
- This creates a recursive structure where each item can contain a child item
- This is the same structure as the parent array items
- This tests that LLxprt doesn't reject self-referential schemas

**Example Valid Data:**
```json
{
  "data": [
    {
      "child": {
        "child": {
          "child": null
        }
      }
    }
  ]
}
```

## Files to Create

| File | Action |
|------|--------|
| `integration-tests/mcp_server_cyclic_schema.test.ts` | CREATE |

## Dependencies

**Must Be Completed First:**
- Plan 5dc7059b (InteractiveRun class implementation)

**The InteractiveRun methods required by this test:**
- `type(text: string)` - Types the `/mcp list` command AND the Enter key ('\r')
- `expectText(text: string)` - Waits for 'tool_with_cyclic_schema' to appear in output

**API Confirmation from 5dc7059b plan:**
- `expectText()` (line 113) - Strips ANSI, case-insensitive, throws on timeout
- `type()` (line 126) - Sends with 5ms delay per character

**Note:** The 5dc7059b plan does NOT include a `sendKeys()` method. The `type()` method is used for all character input, including control characters like '\r' for Enter.

**If InteractiveRun is not yet available:**
This plan is BLOCKED. Do not implement until 5dc7059b is complete.

## Testing Strategy

1. **Run the test:**
   ```bash
   npm test integration-tests/mcp_server_cyclic_schema.test.ts
   ```

2. **Expected behavior:**
   - MCP server script is created in test directory
   - Server is configured in test settings
   - `/mcp list` command shows `tool_with_cyclic_schema`
   - Test validates cyclic schema is accepted

3. **Deflake if needed:**
   ```bash
   npm run deflake integration-tests/mcp_server_cyclic_schema.test.ts
   ```

## Acceptance Criteria

- [ ] Test file created with complete MCP server script
- [ ] Server script includes full SimpleJSONRPC implementation
- [ ] Server exposes `tool_with_cyclic_schema` with recursive schema
- [ ] Schema uses `$ref: '#/properties/data/items'` to create cycle
- [ ] Test uses `.llxprt` config directory
- [ ] Test uses InteractiveRun API (type, expectText) - NO sendKeys method
- [ ] `/mcp list` shows the cyclic schema tool
- [ ] Test passes with deflake
- [ ] Code formatted and linted

## Notes

- This test is important for ensuring LLxprt doesn't regress on complex schema handling
- The cyclic schema pattern (`$ref` to parent structure) is valid JSON Schema
- Some APIs incorrectly reject cyclic schemas - this test catches that
- The MCP server is self-contained (no external dependencies)
- Server implements minimal MCP protocol (initialize, tools/list, initialized notification)
